{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#home","title":"Home","text":"<p>Panopti is a Python package for interactive 3D visualization that seamlessly supports remote development setups (e.g. through SSH). It pairs a Flask server with a React+ThreeJS frontend and is designed such that users only need to write Python code, making it painless to setup interactive experiments and scenes. All code examples and demos throughout the documentation are achieved purely using Panopti in Python -- no JavaScript required!.</p> <p>Panopti supports various geometric data structures (e.g. meshes, point clouds), UI control elements (e.g. buttons, sliders, color pickers, interactive plots) that are programmable in Python, and global event callbacks (e.g. for camera movement, clicking on geometry).</p> <p>A minimal example looks like: <pre><code>import panopti\nviewer = panopti.connect(server_url=\"http://localhost:8080\", viewer_id=\"client\")\n\n# ... load triangle mesh vertices / faces ...\n\nviewer.add_mesh(vertices=vertices, faces=faces, name=\"MyMesh\")\n\n# Add a UI element w/ Python callback:\ndef my_button_callback(viewer):\n    print('MyButton was pressed!')\nviewer.button(callback=my_button_callback, name='MyButton')\n\n# Add a camera event listener:\n@viewer.events.camera()\ndef my_camera_callback(viewer, camera_info):\n    print('Camera was updated: ', camera_info)\n\nviewer.hold() # prevent script from terminating\n</code></pre></p>"},{"location":"controls/","title":"Controls","text":"<p> Panopti supports a handful of controls elements such as buttons, sliders, color pickers, and even Plotly figures. These controls appear in the viewer UI and optionally call back into your Python code whenever the user interacts with them. The snippets below show their basic usage.</p> <p>Note that these control callbacks are different from the <code>viewer.events</code> handlers (see Events), which respond to built\u2011in viewer actions like camera movement.</p> <p>Available control elements:</p> Button Slider Label Checkbox Dropdown Color Picker Download Button Plotly figure"},{"location":"controls/#button","title":"Button","text":"<p>A simple button with on-click callbacks. <pre><code>def my_button_callback(viewer):\n    print('MyButton was pressed!')\n\nviewer.button(callback=my_button_callback, name='MyButton')\n</code></pre></p>"},{"location":"controls/#slider","title":"Slider","text":"<p>A slider with on-change callbacks. Supports manual expression entry in viewer and has increment/decrement buttons (controlled by <code>step</code> parameter). <pre><code>def my_slider_callback(viewer):\n    print(f\"MySlider was set to: {val}!\")\n\nviewer.slider(callback=my_slider_callback, \n            name='MySlider', \n            min=0.0, \n            max=1.0, \n            initial=0.0, \n            step=0.01, \n            description='Your optional description here')\n</code></pre></p>"},{"location":"controls/#label","title":"Label","text":"<p>A label that supports markdown text. Its callback behaves differently compared to the other control elements -- a label's callback will be triggered when the label is updated, e.g. by calling <code>viewer.get('MyLabel').update('updated text here...')</code> <pre><code>def my_label_callback(viewer):\n    print(f\"This callback is triggered when MyLabel is updated.\")\n\nviewer.label(callback=my_label_callback,\n             name='MyLabel', \n             text='I support **markdown**!')\n</code></pre></p>"},{"location":"controls/#checkbox","title":"Checkbox","text":"<p>A checkbox with on-change callbacks. <pre><code>def my_checkbox_callback(viewer, val):\n    print(f\"MyCheckbox was set to: {val}!\")\n\nviewer.checkbox(callback=my_checkbox_callback, \n                name='MyCheckbox', \n                initial=True)\n</code></pre></p>"},{"location":"controls/#dropdown","title":"Dropdown","text":"<p>A dropdown menu with on-change callbacks. <pre><code>def my_dropdown_callback(viewer, val):\n    print(f\"MyDropdown was set to: {val}!\")\n\nviewer.dropdown(callback=my_dropdown_callback, \n                name='MyDropdown', \n                options=['Option 1', 'Option 2', 'Option 3'], \n                initial=0)\n</code></pre></p>"},{"location":"controls/#color-picker","title":"Color Picker","text":"<p>A color picker with on-change callbacks. </p> <p><code>initial</code> expects an RGBA color. <pre><code>def my_color_picker_callback(viewer, color):\n    print(f\"Color picked (in RGBA): {color}\")\n\nviewer.color_picker(callback=my_color_picker_callback, \n                    name='MyColorPicker', \n                    initial=(0.5, 0.5, 0.5, 1.0))\n</code></pre></p>"},{"location":"controls/#download-button","title":"Download Button","text":"<p>A special button wrapper that allows user code to send arbitrary file downloads to the browser on click. The defined callback must return a <code>bytes</code> object, which represents the binary content of the file to be downloaded. In the example below, <code>f.read()</code> returns the contents of the in-memory file-like object (<code>io.BytesIO</code>) as a <code>bytes</code> object. This binary data is then sent to the browser for download when the button the clicked. For example, push an <code>.obj</code> file download to your viewer: <pre><code>import io, numpy as np, trimesh\ndef download_mesh_callback(viewer):\n    tm = trimesh.Trimesh(vertices=verts, faces=faces, process=False)\n    f = io.BytesIO()\n    tm.export(file_obj=f, file_type='obj') # write to BytesIO object\n    f.seek(0)\n    return f.read()\n\nviewer.download_button(callback=download_mesh_callback, \n                    name=\"Download Mesh\", \n                    filename=\"mesh.obj\")\n</code></pre></p>"},{"location":"controls/#plotly-figure","title":"Plotly figure","text":"<p>You can embed interactive Plotly figures into the viewer as well. Below we customize a Plotly figure in Python, then send its JSON schematic to the viewer. Currently Plotly elements do not support callbacks. Of course, this functionality requires Plotly: <code>pip install plotly==5.22.0</code>. <pre><code>import plotly.graph_objects as go\nfig = go.Figure(...)\n# ... define figure here ...\nviewer.add_plotly(fig.to_plotly_json(), name='Histogram')\n</code></pre></p> <p>Warning</p> <p>Some versions of Plotly seem to misbehave with this functionality. We recommend using version <code>plotly==5.22.0</code>.</p>"},{"location":"events/","title":"Viewer Events","text":"<p>Panopti exposes several event callbacks through Python decorators, which are accessible through <code>viewer.events</code>, the usage pattern looks like: <pre><code>import panopti\nviewer = panopti.connect(server_url=\"http://localhost:8080\", viewer_id='client')\n\n@viewer.events.camera()\ndef my_camera_event(viewer, camera_info):\n    # this function is triggered when the viewer camera is manipulated\n    ...\n</code></pre> These callbacks give user code access to various events in the default viewer -- not to be mistaken with the callbacks for user-defined controls (see Controls).</p> <p>Available event decorators:</p> Camera - <code>@viewer.events.camera()</code> <p>The <code>camera</code> event is triggered when the user manipulates the viewer  camera (e.g. orbit, pan, zoom). This event provides a <code>dict</code> containing  information about the camera's current state.  Example usage: <pre><code>@viewer.events.camera()\ndef camera_event(viewer, camera_info):\n    print('Camera was updated!')\n    # swivel scene mesh to always face the camera (in Y-axis):\n    mesh = viewer.get('myMesh')\n    mx, my, mz = mesh.position\n    cx, cy, cz = camera_info['position']\n    yaw = math.atan2(cx - mx, cz - mz)\n    mesh.rotation = [0, yaw, 0]\n    mesh.update(rotation=[0, yaw, 0])\n</code></pre> <code>camera_info</code> is a dict containing:</p> key meaning type position camera world coords list rotation camera XYZ euler rotation list quaternion camera rotation as quaternion list up camera up-vector list target point the camera is looking at list fov vertical field-of-view (degrees) float near near-plane distance float far far-plane distance float aspect viewport aspect ratio (w / h) float Inspect - <code>@viewer.events.inspect()</code> <p>The <code>inspect</code> event is triggered when the inspection tool is used in the viewer (e.g. when clicking on a mesh to inspect its local vertex indices). Example usage: <pre><code>@viewer.events.inspect()\ndef inspect_event(viewer, inspect_info):\n    print(f\"User clicked on a {inspect_info['object_type']} object.\")\n    if inspect_info['object'type'] == 'mesh':\n        print('Selected face index: ', inspect_info['inspect_result']['face_index'])\n</code></pre> <code>inspect_info</code> is a dict containing:</p> key meaning type object_name <code>name</code> attribute of selected object str object_type type of Panopti object selected (e.g., <code>'mesh'</code>, <code>'points'</code>) str world_coords XYZ world coordinates of the pick point list screen_coords integer pixel coordinates of the pick point list inspect_result geometry\u2011specific data at the pick point:Mesh / AnimatedMesh\u00a0\u00a0\u2022 <code>face_index</code>: <code>int</code> (clicked face)\u00a0\u00a0\u2022 <code>vertex_indices</code>: <code>list[int]</code> (three vertices of face)PointCloud\u00a0\u00a0\u2022 <code>point_index</code>: <code>int</code> (clicked point) dict Select Object - <code>@viewer.events.select_object()</code> <p>The <code>select_object</code> event is triggered when a geometric structure is selected in the viewer -- either by clicking on the object directly or selecting it in the layers panel. Example usage: <pre><code>@viewer.events.object_selection()\ndef object_selection_event(viewer, object_name):\n    print(f\"User selected {object_name}\")\n</code></pre> <code>object_name: str</code> is the selected object's name.</p> Control - <code>@viewer.events.control()</code> <p>The <code>control</code> event is triggered when any control element is interacted with. Example usage: <pre><code>@viewer.events.control()\ndef control_event(viewer, control_name, value):\n    print(f\"User updated {control_name} to {value}\")\n</code></pre> <code>control_name: str</code> is the selected object's name</p> <p><code>value</code> is the control element's new value</p> Update Object - <code>@viewer.events.update_object()</code> <p>The <code>update_object</code> event is triggered when any geometric object has an attribute updated, e.g. through <code>.update(...)</code>. Example usage: <pre><code>@viewer.events.update_object()\ndef update_object_event(viewer, object_name, data):\n    print(f\"Object {object_name} updated with attributes: {data.keys()}\")\n</code></pre> <code>object_name: str</code> is the updated object's name</p> <p><code>data: dict</code> holds the updated attributes of the object, e.g. <code>{'vertices': ...}</code></p>"},{"location":"getting_started/","title":"Getting started","text":""},{"location":"getting_started/#installation","title":"Installation","text":""},{"location":"getting_started/#installing-from-pip","title":"Installing from pip","text":"<pre><code>pip install panopti\n</code></pre>"},{"location":"getting_started/#installing-from-source","title":"Installing from source","text":"<pre><code>git clone https://github.com/ArmanMaesumi/panopti\ncd panopti/frontend \n\n# build frontend viewer\nnpm install\nnpm run build\n\n# install python package\ncd ..\npip install .\n</code></pre>"},{"location":"getting_started/#running-a-panopti-server","title":"Running a Panopti server","text":"<p>The Panopti server runs in an isolated process as your user code, hence you should run it in a separate terminal. You may use the convenience module: <pre><code>python -m panopti.run_server --host localhost --port 8080\n</code></pre> or manually through your own script <pre><code>import panopti\npanopti.start_server(host='localhost', port=8080, debug=True)\n</code></pre> The viewer will then be available at http://http://localhost:8080/?viewer_id=<code>your_client_id</code></p> <p>Note: Your application will register its own <code>viewer_id</code>, which will affect the link above (see below).</p>"},{"location":"getting_started/#connecting-to-a-panopti-server","title":"Connecting to a Panopti server","text":"<p>Once your server is running, your main application can connect to the instance via: <pre><code>import panopti\nviewer_id = \"client\" # choose a unique id here\nviewer = panopti.connect(server_url=\"http://localhost:8080\", viewer_id=viewer_id) \n# now in your browser open: http://localhost:8080/?viewer_id=client\n\n# ... your code here ...\n\nviewer.hold() # prevent the script from terminating\n</code></pre> The server uses <code>viewer_id</code> to distinguish between different scripts that may be running concurrently. This argument must be specified even when just one session is active.</p>"},{"location":"getting_started/#hello-world-with-panopti","title":"Hello World with Panopti","text":"<p>Now let's add a simple mesh to the viewer. <pre><code>import panopti\nimport trimesh # only for io\nviewer = panopti.connect(server_url=\"http://localhost:8080\", viewer_id='client') \n\nmesh = trimesh.load('demosthenes.obj')\nverts, faces = mesh.vertices, mesh.faces\n\npano.add_mesh(\n    vertices=verts,\n    faces=faces,\n    name=\"Statue\",\n    color=(0.7, 0.7, 0.7)\n)\n\nviewer.hold() # prevent the script from terminating\n</code></pre> Done! For more elaborate examples, See the <code>Examples</code> tab, or:</p> <ul> <li>Importing Geometry</li> <li>Controls &amp; Callbacks</li> <li>Viewer State &amp; Events</li> </ul>"},{"location":"getting_started/#working-remotely-ssh","title":"Working remotely (SSH)","text":"<p>Panopti seamlessly integrates into remote work setups. Please refer to the Remote SSH page for details.</p>"},{"location":"remote_ssh/","title":"Remote SSH","text":"<p>Panopti seamlessly integrates into remote work setups. If you are using VSCode (e.g. with the <code>Remote - SSH</code> extension), then simply starting the server will automatically take care of port forwarding. If you are using SSH from a terminal, you can forward the Panopti port like so:</p> <p><code>ssh -L 8008:localhost:8080 user@remote.host</code></p> <p>Which pushes the remote <code>8080</code> port into the port <code>8008</code> locally, for example. Note that working remotely may incur additional latency in the viewer.</p>"},{"location":"todo/","title":"Todo","text":"<p>Misc:</p> <ul> <li>Fix <code>label</code> interface, right now you cannot specify text immediately on creation.</li> <li>If a <code>slider</code>'s name contains a space, then its corresponding textbox breaks.</li> <li>Make <code>Restart Script</code> button also call <code>Refresh Scene</code> to clean stale data.</li> <li>While a geometry is selected, calling e.g. <code>object.update(rotation=...)</code> will not update the entries in the transform panel (util you select the object again).</li> <li>Tune default lighting.</li> <li>Many object attributes are returned as a Python <code>List</code>, maybe we should prefer <code>np.array</code> by default?</li> </ul> <p>Small Features:</p> <ul> <li>Add callbacks to Plotly (not sure if possible)?</li> <li>Add more Event decorators: <ul> <li><code>object_update</code>: triggered when any object attribute is updated</li> <li><code>controls</code>: triggered when any control element is interacted with</li> <li><code>mouse</code>: expose a collection of mouse events through e.g. <code>events.mouse.[on_click, on_move, etc.]</code></li> </ul> </li> <li>Allow updating camera settings from user code.</li> </ul> <p>Larger Features:</p> <ul> <li>Add support for SDF rendering</li> <li>Add a comprehensive <code>.ini</code> settings file that can be modified directly, in Python, and through a UI modal in the frontend</li> </ul>"},{"location":"examples/controls_callbacks/","title":"Controls &amp; Callbacks","text":"<p>This example demonstrates a mix of user-defined control elements. Each control creates a small widget in the viewer while the corresponding callback stays entirely in Python. The code example below loads a mesh, modifies it using various controls, and displays a Plotly histogram showing relevant data. For a full list of supported controls, see Controls.</p> <pre><code>import panopti\nimport trimesh\nimport numpy as np\nimport plotly.graph_objects as go\nfrom panopti.utils import to_rgb\n\nviewer = panopti.connect(server_url=\"http://localhost:8080\", viewer_id='client')\n\nmesh = trimesh.load('./examples/demosthenes.obj')\nverts, faces = mesh.vertices, mesh.faces\n\n# Add a mesh\nvertex_colors = to_rgb(verts[:, 1], cmap='viridis')\nviewer.add_mesh(\n    vertices=verts,\n    faces=faces,\n    name=\"Statue\",\n    vertex_colors=vertex_colors,\n)\n\n# --- Let's add some controls ---\n\n# On button press, randomly rotate mesh\ndef callback_random_rotate(viewer):\n    random_rotation = np.random.uniform(0, 2 * np.pi, (3,))\n\n    yaxis_only = viewer.get('Y-axis Only').value() # read checkbox value\n    if yaxis_only: # zero out X,Z axes\n        random_rotation[[0, 2]] = 0\n\n    viewer.get('Statue').update(rotation=rotation)\n    plot_histogram(viewer) # update histogram\nviewer.button(callback=callback_random_rotate, name='Randomly rotate mesh')\n\n\n# Checkbox that changes behavior of button action -- we can leave the callback blank\nviewer.checkbox(callback=None, name='Y-axis Only', initial=True)\n\n\n# Override mesh color using a color picker:\ndef callback_recolor_mesh(viewer, color):\n    mesh = viewer.get(\"Statue\")\n    if mesh is not None:\n        mesh.update(vertex_colors=None)\n        mesh.update(color=(color[0], color[1], color[2]), opacity=color[3])\nviewer.color_picker(callback=callback_recolor_mesh, name='Recolor Mesh', initial=(0.5, 0.5, 0.5, 1.0))\n\n\n# Slider that adds Gaussian noise to the mesh\ndef callback_add_noise(viewer, value):\n    noise = value * np.random.randn(*verts.shape)\n    new_verts = verts.copy() + noise\n    viewer.get('Statue').update(vertices=new_verts)\n    plot_histogram(viewer) # update histogram\nviewer.slider(callback=callback_add_noise, name='GaussinNoiseSTD', min=0.0, max=0.2, initial=0.0, step=0.01)\n\n\n# Plot a stylized histogram of the mesh vertex y-coordinates:\ndef plot_histogram(viewer):\n     # Get the y-coordinates of current mesh (as its shown in the viewer)\n    data = np.asarray(viewer.get('Statue').viewer_verts)[:,1]\n    counts, bins = np.histogram(data, bins=128)\n    bin_centers = 0.5 * (bins[:-1] + bins[1:])\n    widths = bins[1:] - bins[:-1]\n    fig = go.Figure(\n        go.Bar(\n            x=bin_centers,\n            y=counts,\n            width=widths,\n            marker=dict(\n                color=bin_centers,\n                colorscale='Viridis',\n                showscale=False,\n                colorbar=dict(title='Bin value'),\n                line=dict(width=0)\n            ),\n            showlegend=False\n        )\n    )\n    fig.update_layout(\n        margin=dict(l=0, r=0, t=20, b=0),\n        title_text='Histogram of Statue Y-coordinates',\n        xaxis_title='Statue Y-coordinates',\n        yaxis_title='Count',\n        showlegend=False,\n    )\n    fig.update_layout(title_font_size=12)\n    fig.update_layout(title_x=0.13, title_xanchor='left')\n    fig.update_xaxes(title_font_size=12, tickfont_size=8)\n    fig.update_yaxes(title_font_size=12, tickfont_size=8)\n    viewer.add_plotly(fig.to_plotly_json(), name='Histogram')\nplot_histogram(viewer)\n\nviewer.hold() # prevent script from terminating\n</code></pre>"},{"location":"examples/importing_geometry/","title":"Importing geometry","text":"<p>Panopti supports a variety of geometric data structures, see for example Geometry \u2192 Mesh. The example below demonstrates how these structures can be added to your scene.</p> <pre><code>import panopti\nimport numpy as np\nimport trimesh # just for io\nfrom panopti.utils import to_rgb\n\nviewer = panopti.connect(server_url='http://localhost:8080', viewer_id='client')\n\nmesh = trimesh.load('./examples/demosthenes.obj')\nverts, faces = mesh.vertices, mesh.faces\nverts = np.ascontiguousarray(verts, dtype=np.float32)\nfaces = np.ascontiguousarray(faces, dtype=np.int32)\nnormals = np.ascontiguousarray(mesh.vertex_normals, dtype=np.float32)\nverts = verts - verts.mean(axis=0, keepdims=True)  # Center the mesh\n\n### ----- Add Mesh -----\nvertex_colors = to_rgb(verts[:, 1], cmap='viridis')\nviewer.add_mesh(\n    vertices=verts,\n    faces=faces,\n    name=\"StatueMesh\",\n    vertex_colors=vertex_colors,\n)\n\n### ----- Add Point Cloud -----\npoints = verts.copy()\npoints[:,0] += 2\npoint_colors = to_rgb(points[:, 1], cmap='viridis')\nviewer.add_points(\n    points=points,\n    name=\"StatuePoints\",\n    colors=point_colors,\n    size=0.015,\n)\n\n### ----- Add Arrows pointing to another Point Cloud -----\npoints2 = points + (0.8, 0.8, -1.5)\nrandom_subset = np.random.choice(points.shape[0], size=points.shape[0] // 128, replace=False)\nviewer.add_points(\n    points=points2[random_subset],\n    name=\"PointsSubset\",\n    colors=point_colors[random_subset],\n    size=0.05,\n)\nviewer.add_arrows(\n    starts=points2[random_subset],\n    ends=points[random_subset],\n    name=\"Arrows\",\n    color=(0.01, 0.01, 0.01),\n    width=0.01,\n)\n\n### ----- Add AnimatedMesh -----\ndef whacky_transform(vertices, normals, t):\n    # 1) swirl around Y: angle = t*2\u03c0 * radius\n    radii  = np.linalg.norm(vertices, axis=1)\n    angles = radii * (t * 2*np.pi)\n    cosA   = np.cos(angles)[:,None]\n    sinA   = np.sin(angles)[:,None]\n    x, y, z = vertices[:,0:1], vertices[:,1:2], vertices[:,2:3]\n\n    x_sw = x * cosA - z * sinA\n    z_sw = x * sinA + z * cosA\n    verts_swirl = np.concatenate([x_sw, y, z_sw], axis=1)\n\n    # 2) pulsate along normals: sin(frequency*radius + phase) * amplitude\n    freq      = 6.0                   # number of ripples\n    amp_base  = 0.2                   # max offset\n    phase     = t * np.pi             # phase shift\n    offsets   = np.sin(radii * freq + phase) * amp_base * t\n    verts_out = verts_swirl + normals * offsets[:,None]\n\n    return verts_out\n\n# bake whacky animation:\nverts_animation = []\nfor t in np.linspace(0, 1, 50):\n    temp_verts = whacky_transform(verts.copy(), normals, t) - (2.0, 0.0, 0.0)\n    verts_animation.append(temp_verts)\nverts_animation = np.stack(verts_animation)\n\n# boomerang the animation\nverts_animation = np.concatenate([verts_animation, verts_animation[::-1]], axis=0) \n\nviewer.add_animated_mesh(\n    vertices=verts_animation,\n    faces=faces,\n    name=\"WhackyAnimation\",\n    framerate=24,\n    vertex_colors=vertex_colors,\n)\n\nviewer.hold() # prevent script from terminating\n</code></pre>"},{"location":"examples/viewer_state_events/","title":"Viewer State & Events","text":"<p>Panopti offers various mechanisms for reading and modifying the viewer's state.</p>"},{"location":"examples/viewer_state_events/#geometry","title":"Geometry","text":"<p>All geometric objects support the following get, update, delete functions:</p> <pre><code>import panopti\nviewer = panopti.connect(...)\nviewer.add_mesh(name='MyMesh', ...)\n\n# Get mesh:\nmymesh = viewer.get('MyMesh')\n\n# Update mesh vertices and vertex_colors:\nmymesh.update(vertices=..., vertex_colors=...)\n\n# Delete mesh:\nmymesh.delete()\n</code></pre>"},{"location":"examples/viewer_state_events/#camera","title":"Camera","text":"<p>You can directly request current camera data from the viewer by doing: <pre><code>import panopti\nviewer = panopti.connect(...)\ncamera_data = viewer.camera()\n</code></pre> This function returns a <code>dict</code> containing the same parameters as the camera event decorator (see Events):</p> key meaning type position camera world coords list rotation camera XYZ euler rotation list quaternion camera rotation as quaternion list up camera up-vector list target point the camera is looking at list fov vertical field-of-view (degrees) float near near-plane distance float far far-plane distance float aspect viewport aspect ratio (w / h) float <p>Note: Currently there is no functionality to update the viewer camera from Python.</p>"},{"location":"examples/viewer_state_events/#transformations","title":"Transformations","text":"<p>Currently this feature only supports Mesh and AnimatedMesh scene objects.</p> <p>The transformation panel allows you to interactively translate, rotate, and scale geometric data structures in the viewer. To open the transformation panel, simply select a scene object. The transformation state can be accessed by your code through property fields of scene geometries.</p> <p>Example: <pre><code>import panopti\nimport numpy as np\nviewer = panopti.connect(server_url=\"http://localhost:8080\", viewer_id=\"client\")\n\n# ... load triangle mesh vertices / faces ...\n\nviewer.add_mesh(vertices=vertices, faces=faces, name=\"MyMesh\")\n\n# Add a button that reads off the mesh's current transformation:\ndef my_button_callback(viewer):\n    mesh = viewer.get('MyMesh')\n\n    # request MyMesh's 4x4 transformation matrix:\n    trans_mat = mesh.trans_mat\n\n    # or directly access the transformed vertex tensor:\n    transformed_verts = mesh.viewer_verts\n\n    # ... do something here ...\n\nviewer.button(callback=my_button_callback, name='MyButton')\n\nviewer.hold() # prevent script from terminating\n</code></pre></p> SceneObject.trans_mat SceneObject.viewer_verts"},{"location":"examples/viewer_state_events/#trans_mat","title":"trans_mat","text":"<p>Fetches the objects current 4x4 transformation matrix. <pre><code>viewer.get('MyObject').trans_mat\n</code></pre></p>"},{"location":"examples/viewer_state_events/#viewer_verts","title":"viewer_verts","text":"<p>Fetches the objects current vertices with <code>trans_mat</code> pre-applied <pre><code>viewer.get('MyObject').viewer_verts\n</code></pre></p>"},{"location":"examples/viewer_state_events/#events","title":"Events","text":"<p>Panopti exposes several event callbacks through Python decorators, which are accessible through <code>viewer.events</code>, the usage pattern looks like: <pre><code>import panopti\nviewer = panopti.connect(server_url=\"http://localhost:8080\", viewer_id='client')\n\n@viewer.events.camera()\ndef my_camera_event(viewer, camera_info):\n    # this function is triggered when the viewer camera is manipulated\n    ...\n</code></pre> These callbacks give user code access to various viewer events, see Events for a list of supported decorators.</p>"},{"location":"geometry/animated_mesh/","title":"Animated Meshes","text":"<p>The Panopti <code>AnimatedMesh</code> object represents a temporally evolving triangular surface mesh. To add an animated mesh to your scene: <pre><code>import panopti\nimport trimesh # just for io\nimport numpy as np\n\nviewer = panopti.connect(server_url=\"http://localhost:8080\", viewer_id='client')\n\nmesh = trimesh.load('mesh.obj')\nverts = mesh.vertices   # (V, 3) ndarray\nfaces = mesh.faces      # (F, 3) ndarray \n\n# Create simple animation of sliding mesh\nnum_frames = 60\ntemporal_offset = np.linspace([0, 0, 0], [1, 0, 0], num=num_frames)[:, None, :]\nverts_animation = np.repeat(verts[np.newaxis], repeats=num_frames, axis=0)\nverts_animation += temporal_offset\n\nviewer.add_animated_mesh(\n    vertices=verts_animation,\n    faces=faces,\n    name=\"myAnimatedMesh\",\n    framerate=24,\n    color=(0.5, 0.5, 0.5)\n)\n</code></pre></p> BaseViewer.add_animated_mesh <p>Adds an AnimatedMesh object to the viewer.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>ndarray</code> <p>(T, V, 3) array of vertex coordinates for each frame.</p> required <code>faces</code> <code>ndarray</code> <p>(F, 3) array of face indices.</p> required <code>name</code> <code>str</code> <p>Name for the animated mesh.</p> required <code>framerate</code> <code>float</code> <p>Framerate for the animation.</p> <code>24.0</code> <code>wireframe</code> <code>bool</code> <p>Whether to render the mesh as a wireframe.</p> <code>False</code> <code>visible</code> <code>bool</code> <p>Whether the mesh is visible.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Opacity of the mesh.</p> <code>1.0</code> <code>position</code> <code>Tuple[float, float, float]</code> <p>Position of the mesh (XYZ).</p> <code>(0, 0, 0)</code> <code>rotation</code> <code>Tuple[float, float, float]</code> <p>Rotation of the mesh (XYZ).</p> <code>(0, 0, 0)</code> <code>scale</code> <code>Tuple[float, float, float]</code> <p>Scale of the mesh in (XYZ).</p> <code>(1, 1, 1)</code> <code>color</code> <code>Tuple[float, float, float]</code> <p>Uniform RGB color of the mesh.</p> <code>(0.5, 0.5, 0.5)</code> <code>vertex_colors</code> <code>ndarray</code> <p>(V, 3) array of vertex colors.</p> <code>None</code> <code>face_colors</code> <code>ndarray</code> <p>(F, 3) array of face colors.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>AnimatedMesh</code> <code>AnimatedMesh</code> <p>The created panopti animated mesh object.</p> AnimatedMesh.update(**kwargs) AnimatedMesh.delete() AnimatedMesh.trans_mat <code>property</code> AnimatedMesh.viewer_verts <code>property</code>"},{"location":"geometry/animated_mesh/#update","title":"update","text":"<p>Updates this animated mesh's attributes and propagate updates to the viewer.</p>"},{"location":"geometry/animated_mesh/#delete","title":"delete","text":"<p>Deletes this animated mesh from the viewer.</p>"},{"location":"geometry/animated_mesh/#trans_mat","title":"trans_mat","text":"<p>Returns the 4x4 transformation matrix corresponding to the object's position, rotation, and scale in the viewer.</p>"},{"location":"geometry/animated_mesh/#viewer_verts","title":"viewer_verts","text":"<p>Returns the Mesh's vertices under the transformation given by <code>trans_mat</code>.</p>"},{"location":"geometry/arrows/","title":"Arrows","text":"<p>The Panopti <code>Arrows</code> object represents a collection of floating arrows defined by an array of starting points and ending points. To add arrows to your scene: <pre><code>import panopti\nimport numpy as np\n\nviewer = panopti.connect(server_url=\"http://localhost:8080\", viewer_id='client')\n\nstart_points = np.random.randn(64, 3)\nend_points = start_points.clone()\nend_points[:, 0] += 3.0\n\nviewer.add_arrows(\n    starts=start_points,\n    ends=end_points,\n    name='MyArrows',\n    color=(0.5, 0.5, 0.5),\n    width=0.02\n)\n</code></pre></p> BaseViewer.add_arrows <p>Adds an Arrows object to the viewer.</p> <p>Parameters:</p> Name Type Description Default <code>starts</code> <code>ndarray</code> <p>(N, 3) array of start points for the arrows.</p> required <code>ends</code> <code>ndarray</code> <p>(N, 3) array of end points for the arrows.</p> required <code>name</code> <code>str</code> <p>Name for the arrows object.</p> required <code>color</code> <code>ndarray</code> <p>(N, 3) or (3,) array of RGB colors for the arrows.</p> <code>(0, 0, 0)</code> <code>width</code> <code>float</code> <p>Width of the arrows.</p> <code>0.01</code> <code>visible</code> <code>bool</code> <p>Whether the arrows are visible.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Opacity of the arrows.</p> <code>1.0</code> <p>Returns:</p> Name Type Description <code>Arrows</code> <code>Arrows</code> <p>The created panopti arrows object.</p> Arrows.update(**kwargs) Arrows.delete()"},{"location":"geometry/arrows/#update","title":"update","text":"<p>Updates this arrow's attributes and propagate updates to the viewer.</p>"},{"location":"geometry/arrows/#delete","title":"delete","text":"<p>Deletes this arrow from the viewer.</p>"},{"location":"geometry/mesh/","title":"Meshes","text":"<p>The Panopti <code>Mesh</code> object represents a triangular surface mesh. To add a mesh to your scene: <pre><code>import panopti\nimport trimesh # just for io\nimport numpy as np\n\nviewer = panopti.connect(server_url=\"http://localhost:8080\", viewer_id='client')\n\nmesh = trimesh.load('mesh.obj')\nverts = mesh.vertices   # (V, 3) ndarray\nfaces = mesh.faces      # (F, 3) ndarray \n\nviewer.add_mesh(\n    vertices=verts,\n    faces=faces,\n    name=\"MyMesh\",\n    color=(0.5, 0.5, 0.5)\n)\n</code></pre></p> BaseViewer.add_mesh <p>Adds a Mesh object to the viewer.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>ndarray</code> <p>(V, 3) array of vertex coordinates.</p> required <code>faces</code> <code>ndarray</code> <p>(F, 3) array of face indices.</p> required <code>name</code> <code>str</code> <p>Name for the mesh.</p> required <code>wireframe</code> <code>bool</code> <p>Whether to render the mesh as a wireframe.</p> <code>False</code> <code>visible</code> <code>bool</code> <p>Whether the mesh is visible.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Opacity of the mesh.</p> <code>1.0</code> <code>position</code> <code>Tuple[float, float, float]</code> <p>Position of the mesh (XYZ).</p> <code>(0, 0, 0)</code> <code>rotation</code> <code>Tuple[float, float, float]</code> <p>Rotation of the mesh (XYZ).</p> <code>(0, 0, 0)</code> <code>scale</code> <code>Tuple[float, float, float]</code> <p>Scale of the mesh in (XYZ).</p> <code>(1, 1, 1)</code> <code>color</code> <code>Tuple[float, float, float]</code> <p>Uniform RGB color of the mesh.</p> <code>(0.5, 0.5, 0.5)</code> <code>vertex_colors</code> <code>ndarray</code> <p>(V, 3) array of vertex colors.</p> <code>None</code> <code>face_colors</code> <code>ndarray</code> <p>(F, 3) array of face colors.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Mesh</code> <code>Mesh</code> <p>The created panopti mesh object.</p> Mesh.update(**kwargs) Mesh.delete() Mesh.trans_mat <code>property</code> Mesh.viewer_verts <code>property</code>"},{"location":"geometry/mesh/#update","title":"update","text":"<p>Updates this mesh's attributes and propagate updates to the viewer.</p>"},{"location":"geometry/mesh/#delete","title":"delete","text":"<p>Deletes this mesh from the viewer.</p>"},{"location":"geometry/mesh/#trans_mat","title":"trans_mat","text":"<p>Returns the 4x4 transformation matrix corresponding to the object's position, rotation, and scale in the viewer.</p>"},{"location":"geometry/mesh/#viewer_verts","title":"viewer_verts","text":"<p>Returns the Mesh's vertices under the transformation given by <code>trans_mat</code>.</p>"},{"location":"geometry/point_cloud/","title":"Point Clouds","text":"<p>The Panopti <code>Points</code> object represents a point cloud. To add a point cloud to your scene: <pre><code>import panopti\nimport numpy as np\n\nviewer = panopti.connect(server_url=\"http://localhost:8080\", viewer_id='client')\n\npoints = np.random.randn(128, 3)\n\nviewer.add_points(\n    points=points,\n    name=\"MyPointCloud\",\n    colors=(0.5, 0.5, 0.5),\n    size=0.01\n)\n</code></pre></p> BaseViewer.add_points <p>Adds a Point Cloud object to the viewer.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>ndarray</code> <p>(N, 3) array of point coordinates.</p> required <code>name</code> <code>str</code> <p>Name for the points object.</p> required <code>colors</code> <code>ndarray</code> <p>(N, 3) or (3,) array of RGB colors for the points.</p> <code>(0.5, 0.5, 0.5)</code> <code>size</code> <code>float</code> <p>Size of the points.</p> <code>0.01</code> <code>visible</code> <code>bool</code> <p>Whether the points are visible.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Opacity of the points.</p> <code>1.0</code> <p>Returns:</p> Name Type Description <code>Points</code> <code>Points</code> <p>The created panopti points object.</p> Points.update(**kwargs) Points.delete()"},{"location":"geometry/point_cloud/#update","title":"update","text":"<p>Updates this point cloud's attributes and propagate updates to the viewer.</p>"},{"location":"geometry/point_cloud/#delete","title":"delete","text":"<p>Deletes this point cloud from the viewer.</p>"},{"location":"viewer/camera/","title":"Camera","text":"<p>You can directly request current camera data from the viewer by doing: <pre><code>import panopti\nviewer = panopti.connect(server_url=\"http://localhost:8080\", viewer_id='client')\n\ncamera_data = viewer.camera()\n\nviewer.hold()\n</code></pre> This function returns exactly the same parameters as the camera event decorator (see Events):</p> key value type position camera world coords List rotation camera XYZ rotation List quaternion camera rotation represented as quaternion List up camera up vector List target camera \"look at\" position List fov camera frustum vertical field of view Float near camera frustum near plane Float far camera frustum far plane Float aspect camera frustum aspect ratio Float <p>Note: Currently there is no functionality to update the viewer camera from Python.</p>"},{"location":"viewer/console_mirroring/","title":"Console Mirroring","text":"<p> Panopti has a built-in floating console that relays your script's prints/errors directly to the viewer, making it easy to debug without switching between windows. To propagate your script's print stream to the viewer, simply call <code>capture_prints()</code> like so:</p> <pre><code>import panopti\nviewer = panopti.connect(server_url=\"http://localhost:8080\", viewer_id='client')\nviewer.capture_prints(capture_stderr=True)\n\n# ... your code ..\n\nviewer.hold()\n</code></pre> <p>The propagated print statements are then accessible in the viewer's <code>Console</code>, which can be opened by clicking the following button: </p>"},{"location":"viewer/transformations/","title":"Transformations","text":"<p>Currently this feature only supports Mesh and AnimatedMesh scene objects.</p> <p>The transformation panel allows you to interactively translate, rotate, and scale geometric data structures in the viewer. To open the transformation panel, simply select a scene object. The transformation state can be accessed by your code through property fields of scene geometries.</p> <p>Example: <pre><code>import panopti\nimport numpy as np\nviewer = panopti.connect(server_url=\"http://localhost:8080\", viewer_id=\"client\")\n\n# ... load triangle mesh vertices / faces ...\n\nviewer.add_mesh(vertices=vertices, faces=faces, name=\"MyMesh\")\n\n# Add a button that reads off the mesh's current transformation:\ndef my_button_callback(viewer):\n    mesh = viewer.get('MyMesh')\n\n    # request MyMesh's 4x4 transformation matrix:\n    trans_mat = mesh.trans_mat\n\n    # or directly access the transformed vertex tensor:\n    transformed_verts = mesh.viewer_verts\n\n    # ... do something here ...\n\nviewer.button(callback=my_button_callback, name='MyButton')\n\nviewer.hold() # prevent script from terminating\n</code></pre></p> SceneObject.trans_mat SceneObject.viewer_verts"},{"location":"viewer/transformations/#trans_mat","title":"trans_mat","text":"<p>Fetches the objects current 4x4 transformation matrix. <pre><code>viewer.get('MyObject').trans_mat\n</code></pre></p>"},{"location":"viewer/transformations/#viewer_verts","title":"viewer_verts","text":"<p>Fetches the objects current vertices with <code>trans_mat</code> pre-applied <pre><code>viewer.get('MyObject').viewer_verts\n</code></pre></p>"}]}