{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#_1","title":"Home","text":"<p>Panopti is a Python package for interactive 3D visualization that seamlessly supports remote development setups (e.g. through SSH). It pairs a Flask server with a React+ThreeJS frontend and is designed such that users only need to write Python code, making it painless to setup interactive experiments and scenes. All code examples and demos throughout the documentation are achieved purely using Panopti in Python -- no JavaScript required!</p> <p>Panopti supports various geometric data structures (e.g. meshes, point clouds), UI control elements (e.g. buttons, sliders, color pickers, interactive plots) that are programmable in Python, and global event callbacks (e.g. for camera movement, clicking on geometry).</p> <p>A minimal example looks like: <pre><code>import panopti\nviewer = panopti.connect(server_url=\"http://localhost:8080\", viewer_id=\"client\")\n\n# ... load triangle mesh vertices / faces ...\n\nviewer.add_mesh(vertices=vertices, faces=faces, name=\"MyMesh\")\n\n# Add a UI element w/ Python callback:\ndef my_button_callback(viewer):\n    print('MyButton was pressed!')\nviewer.button(callback=my_button_callback, name='MyButton')\n\n# Add a camera event listener:\n@viewer.events.camera()\ndef my_camera_callback(viewer, camera_info):\n    print('Camera was updated: ', camera_info)\n\nviewer.hold() # prevent script from terminating\n</code></pre></p>"},{"location":"controls/","title":"Controls","text":"<p> Panopti supports a handful of controls elements such as buttons, sliders, color pickers, and even Plotly figures. These controls appear in the viewer UI and optionally call back into your Python code whenever the user interacts with them. The snippets below show their basic usage.</p> <p>Note that these control callbacks are different from the <code>viewer.events</code> handlers (see Events), which respond to built-in viewer actions like camera movement.</p> <p>An example for control elements is given below. In general, control elements are defined through an (optional) Python callback function, and with a name that is used to access it later through <code>viewer.get(name)</code>. The name will also serve as a display label in the frontend. The state of control elements can be retrieved with the <code>.value()</code> function (see below). </p> <p>Your control callback function's signature should resembles those below, e.g. for sliders:  <code>def mycallback(viewer, value)</code>. All callbacks get a reference to the viewer as the first positional argument, relevant control-specific arguments follow.</p> <pre><code>import panopti\n\nviewer = panopti.connect(server_url='http://localhost:8080', viewer_id='client')\n\ndef callback_submit_button(viewer):\n    # User clicked submit, let's run a compute job\n\n    # update label:\n    label = viewer.get('compute_label')\n    label.update('Running job...')\n\n    extra_fancy = viewer.get('Extra fancy').value() # grab the current checkbox value\n    result = run_fancy_calculation(extra_fancy=extra_fancy)\n\n    label.update('Done! Results: ', results)\n\nviewer.button(callback=callback_submit_button, name='Submit')\n\n# Add a checkbox that modifies our function above, no callback needed\nviewer.checkbox(callback=None, name='Extra Fancy')\n\n# Add a label that is updated when our job is complete\nviewer.label(callback=None, name='compute_label', text='Waiting...')\n\nviewer.hold()\n</code></pre> <p>Available control elements:</p> Button Slider Label Checkbox Dropdown Color Picker Download Button Plotly figure"},{"location":"controls/#button","title":"Button","text":"<p>A simple button with on-click callbacks. <pre><code>def my_button_callback(viewer):\n    print('MyButton was pressed!')\n\nviewer.button(callback=my_button_callback, name='MyButton')\n</code></pre></p>"},{"location":"controls/#slider","title":"Slider","text":"<p>A slider with on-change callbacks. Supports manual expression entry in viewer and has increment/decrement buttons (controlled by <code>step</code> parameter). <pre><code>def my_slider_callback(viewer, val):\n    print(f\"MySlider was set to: {val}!\")\n\nviewer.slider(callback=my_slider_callback, \n            name='MySlider', \n            min=0.0, \n            max=1.0, \n            initial=0.0, \n            step=0.01, \n            description='Your optional description here')\n</code></pre></p>"},{"location":"controls/#label","title":"Label","text":"<p>A label that supports markdown text. Its callback behaves differently compared to the other control elements -- a label's callback will be triggered when the label is updated, e.g. by calling <code>viewer.get('MyLabel').update('updated text here...')</code> <pre><code>def my_label_callback(viewer):\n    print(f\"This callback is triggered when MyLabel is updated.\")\n\nviewer.label(callback=my_label_callback,\n             name='MyLabel', \n             text='I support **markdown**!')\n</code></pre></p>"},{"location":"controls/#checkbox","title":"Checkbox","text":"<p>A checkbox with on-change callbacks. <pre><code>def my_checkbox_callback(viewer, val):\n    print(f\"MyCheckbox was set to: {val}!\")\n\nviewer.checkbox(callback=my_checkbox_callback, \n                name='MyCheckbox', \n                initial=True)\n</code></pre></p>"},{"location":"controls/#dropdown","title":"Dropdown","text":"<p>A dropdown menu with on-change callbacks. <pre><code>def my_dropdown_callback(viewer, val):\n    print(f\"MyDropdown was set to: {val}!\")\n\nviewer.dropdown(callback=my_dropdown_callback, \n                name='MyDropdown', \n                options=['Option 1', 'Option 2', 'Option 3'], \n                initial=0)\n</code></pre></p>"},{"location":"controls/#color-picker","title":"Color Picker","text":"<p>A color picker with on-change callbacks. </p> <p><code>initial</code> expects an RGBA color. <pre><code>def my_color_picker_callback(viewer, color):\n    print(f\"Color picked (in RGBA): {color}\")\n\nviewer.color_picker(callback=my_color_picker_callback, \n                    name='MyColorPicker', \n                    initial=(0.5, 0.5, 0.5, 1.0))\n</code></pre></p>"},{"location":"controls/#download-button","title":"Download Button","text":"<p>A special button wrapper that allows user code to send arbitrary file downloads to the browser on click. The defined callback must return a <code>bytes</code> object, which represents the binary content of the file to be downloaded. In the example below, <code>f.read()</code> returns the contents of the in-memory file-like object (<code>io.BytesIO</code>) as a <code>bytes</code> object. This binary data is then sent to the browser for download when the button the clicked. For example, push an <code>.obj</code> file download to your viewer: <pre><code>import io, numpy as np, trimesh\ndef download_mesh_callback(viewer):\n    tm = trimesh.Trimesh(vertices=verts, faces=faces, process=False)\n    f = io.BytesIO()\n    tm.export(file_obj=f, file_type='obj') # write to BytesIO object\n    f.seek(0)\n    return f.read()\n\nviewer.download_button(callback=download_mesh_callback, \n                    name=\"Download Mesh\", \n                    filename=\"mesh.obj\")\n</code></pre></p>"},{"location":"controls/#plotly-figure","title":"Plotly figure","text":"<p>You can embed interactive Plotly figures into the viewer as well. Below we customize a Plotly figure in Python, then send its JSON schematic to the viewer. Currently Plotly elements do not support callbacks. Of course, this functionality requires Plotly: <code>pip install plotly==5.22.0</code>. <pre><code>import plotly.graph_objects as go\nfig = go.Figure(...)\n# ... define figure here ...\nviewer.add_plotly(fig.to_plotly_json(), name='Histogram')\n</code></pre></p> <p>Warning</p> <p>Some versions of Plotly seem to misbehave with this functionality. We recommend using version <code>plotly==5.22.0</code>.</p>"},{"location":"events/","title":"Viewer Events","text":"<p>Panopti exposes several event callbacks through Python decorators, which are accessible through <code>viewer.events</code>, the usage pattern looks like: <pre><code>import panopti\nviewer = panopti.connect(server_url=\"http://localhost:8080\", viewer_id='client')\n\n@viewer.events.camera(throttle=100)\ndef my_camera_event(viewer, camera_info):\n    # this function is triggered when the viewer camera is manipulated\n    # it can be triggered at most once every 100 milliseconds (see throttle argument)\n    ...\n</code></pre> These callbacks give user code access to various events in the default viewer -- not to be mistaken with the callbacks for user-defined controls (see Controls).</p> <p>Throttling event callbacks</p> <p>Many of the event decorators accept an optional <code>throttle: int</code> argument, which limits the frequency at which the callback can be triggered. This is extremely useful when a callback is compute heavy, or if large updates are being propagated from the callback (e.g. updating a mesh's vertex array). This argument accepts an integer time in milliseconds.</p> <p>Note that many events have an innate throttle defined in Panopti's configuration file (see Customization). Any throttle specified in event decorators acts in tandem with those in the configuration file.</p> <p>Available event decorators:</p> Camera - <code>@viewer.events.camera()</code> Inspect - <code>@viewer.events.inspect()</code> Select Object - <code>@viewer.events.select_object()</code> Control - <code>@viewer.events.control()</code> Update Object - <code>@viewer.events.update_object()</code> Gizmo - <code>@viewer.events.gizmo()</code>"},{"location":"events/#camera-event","title":"Camera Event","text":"<p>The <code>camera</code> event is triggered when the user manipulates the viewer  camera (e.g. orbit, pan, zoom). This event provides a <code>CameraInfo</code> object  containing information about the camera's current state.</p> <p>Parameters:</p> Name Type Description Default <code>throttle</code> <code>int</code> <p>Throttle interval in milliseconds. If provided,  the callback will only be called at most once per throttle interval.</p> <code>None</code> <p>Example usage: <pre><code>@viewer.events.camera()\ndef camera_event(viewer, camera_info):\n    print('Camera was updated!')\n    # swivel scene mesh to always face the camera (in Y-axis):\n    mesh = viewer.get('myMesh')\n    mx, my, mz = mesh.position\n    cx, cy, cz = camera_info.position  # dot-access notation\n    yaw = math.atan2(cx - mx, cz - mz)\n    mesh.rotation = [0, yaw, 0]\n    mesh.update(rotation=[0, yaw, 0])\n\n# Or with throttling (100ms interval)\n@viewer.events.camera(throttle=100)\ndef throttled_camera_event(viewer, camera_info):\n    print('Throttled camera update!')\n</code></pre> <code>camera_info</code> is a <code>CameraInfo</code> object with the following attributes:</p> attribute meaning type position camera world coords ndarray rotation camera XYZ euler rotation ndarray quaternion camera rotation as quaternion ndarray up camera up-vector ndarray target point the camera is looking at ndarray fov vertical field-of-view (degrees) float near near-plane distance float far far-plane distance float aspect viewport aspect ratio (w / h) float projection_mode 'perspective' or 'orthographic' str"},{"location":"events/#inspection-event","title":"Inspection Event","text":"<p>The <code>inspect</code> event is triggered when the inspection tool is used in the viewer (e.g. when clicking on a mesh to inspect its local vertex indices). Example usage: <pre><code>@viewer.events.inspect()\ndef inspect_event(viewer, inspect_info):\n    print(f\"User clicked on a {inspect_info.object_type} object.\")\n    if inspect_info.object_type == 'mesh':\n        print('Selected face index: ', inspect_info.inspect_result.face_index)\n</code></pre> <code>inspect_info</code> is an <code>InspectInfo</code> object with the following attributes:</p> attribute meaning type object_name <code>name</code> attribute of selected object str object_type type of Panopti object selected (e.g., <code>'mesh'</code>, <code>'points'</code>) str world_coords XYZ world coordinates of the pick point ndarray screen_coords integer pixel coordinates of the pick point ndarray inspect_result geometry-specific data at the pick point:Mesh / AnimatedMesh: <code>MeshInspectResult</code> holding <code>face_index</code> and <code>vertex_indices</code>PointCloud: <code>PointCloudInspectResult</code> holding <code>point_index</code> Union[MeshInspectResult, PointCloudInspectResult]"},{"location":"events/#select-object-event","title":"Select Object Event","text":"<p>The <code>select_object</code> event is triggered when a geometric structure is selected in the viewer -- either by clicking on the object directly or selecting it in the layers panel. Example usage: <pre><code>@viewer.events.object_selection()\ndef object_selection_event(viewer, object_name):\n    print(f\"User selected {object_name}\")\n</code></pre> <code>object_name: str</code> is the selected object's name.</p>"},{"location":"events/#control-event","title":"Control Event","text":"<p>The <code>control</code> event is triggered when any control element is interacted with, e.g. when a slider is moved or a checkbox is toggled.</p> <p>Parameters:</p> Name Type Description Default <code>throttle</code> <code>int</code> <p>Throttle interval in milliseconds. If provided,  the callback will only be called at most once per throttle interval.</p> <code>None</code> <p>Example usage: <pre><code>@viewer.events.control()\ndef control_event(viewer, control_name, value):\n    print(f\"User updated {control_name} to {value}\")\n\n# Or with throttling (50ms interval)\n@viewer.events.control(throttle=50)\ndef throttled_control_event(viewer, control_name, value):\n    print(f\"Throttled control update: {control_name} = {value}\")\n</code></pre> <code>control_name: str</code> is the name of the control element</p> <p><code>value</code> is the control element's new value</p>"},{"location":"events/#update-object-event","title":"Update Object Event","text":"<p>The <code>update_object</code> event is triggered when any geometric object has  an attribute updated, e.g. through <code>.update(...)</code> or when the transformation panel is used.</p> <p>Parameters:</p> Name Type Description Default <code>throttle</code> <code>int</code> <p>Throttle interval in milliseconds. If provided,  the callback will only be called at most once per throttle interval.</p> <code>None</code> <p>Example usage: <pre><code>@viewer.events.update_object()\ndef update_object_event(viewer, object_name, data):\n    print(f\"Object {object_name} updated with attributes: {data.keys()}\")\n\n# Or with throttling (100ms interval)\n@viewer.events.update_object(throttle=100)\ndef throttled_update_event(viewer, object_name, data):\n    print(f\"Throttled object update: {object_name}\")\n</code></pre> <code>object_name: str</code> is the updated object's name</p> <p><code>data: dict</code> holds the updated attributes of the object, e.g. <code>{'vertices': ...}</code></p>"},{"location":"events/#gizmo-event","title":"Gizmo Event","text":"<p>The <code>gizmo</code> event is triggered when the gizmo is used to transform an object.</p> <p>Parameters:</p> Name Type Description Default <code>throttle</code> <code>int</code> <p>Throttle interval in milliseconds. If provided,  the callback will only be called at most once per throttle interval.</p> <code>None</code> <p>Example usage: <pre><code>@viewer.events.gizmo()\ndef gizmo_event(viewer, gizmo_info):\n    print(f\"Gizmo was used to transform {gizmo_info.object_name}\")\n\n# Or with throttling (50ms interval)\n@viewer.events.gizmo(throttle=50)\ndef throttled_gizmo_event(viewer, gizmo_info):\n    print(f\"Throttled gizmo transform: {gizmo_info.object_name}\")\n</code></pre> <code>gizmo_info</code> is a <code>GizmoInfo</code> object with the following attributes:</p> Attribute Type Description object_name str Name of the transformed object object_type str Type of Panopti object being transformed (e.g. <code>'mesh'</code>, <code>'points'</code>) trans TransformData New transformation values with <code>position</code>, <code>rotation</code>, <code>scale</code> prev_trans TransformData Previous transformation values when the drag event started"},{"location":"getting_started/","title":"Getting started","text":""},{"location":"getting_started/#installation","title":"Installation","text":""},{"location":"getting_started/#installing-from-pip","title":"Installing from pip","text":"<pre><code>pip install panopti\n</code></pre>"},{"location":"getting_started/#installing-from-source","title":"Installing from source","text":"<pre><code>git clone https://github.com/ArmanMaesumi/panopti\n\n# build frontend viewer\ncd panopti/frontend \nnpm install\nnpm run build\ncd ..\n\n# install python package\npip install .\n</code></pre> <p>Core dependencies (included in pip install): <pre><code>pip install numpy eventlet requests flask flask-socketio python-socketio[client] tomli\n</code></pre></p> <p>Optional dependencies: <pre><code>pip install matplotlib      # for colormap utilities\npip install plotly==5.22.0  # for plotly figure support\n</code></pre></p>"},{"location":"getting_started/#running-a-panopti-server","title":"Running a Panopti server","text":"<p>The Panopti server runs in an isolated process as your user code, hence you should run it in a separate terminal. You may use the convenience module (recommended): <pre><code>python -m panopti.run_server --host localhost --port 8080\n</code></pre> or manually through your own script <pre><code>import panopti\npanopti.start_server(host='localhost', port=8080, debug=False)\n</code></pre></p> <p>Warning</p> <p>You should not run <code>start_server</code> from your main script. The server is meant to run in its own process, which avoids slowing down your code. </p> <p>The viewer will then be available at http://http://localhost:8080/?viewer_id=<code>your_client_id</code></p> <p>Note: Your application will register its own <code>viewer_id</code>, which will affect the link above (see below).</p>"},{"location":"getting_started/#connecting-to-a-panopti-server","title":"Connecting to a Panopti server","text":"<p>Once your server is running, your main application can connect to the instance via: <pre><code>import panopti\nviewer_id = \"client\" # choose a unique id here\nviewer = panopti.connect(server_url=\"http://localhost:8080\", viewer_id=viewer_id) \n# now in your browser open: http://localhost:8080/?viewer_id=client\n\n# ... your code here ...\n\nviewer.hold() # prevent the script from terminating\n</code></pre> The server uses <code>viewer_id</code> to distinguish between different scripts that may be running concurrently. This argument must be specified even when just one session is active.</p>"},{"location":"getting_started/#hello-world-with-panopti","title":"Hello World with Panopti","text":"<p>Now let's add a simple mesh to the viewer. <pre><code>import panopti\nimport trimesh # only for io\nviewer = panopti.connect(server_url=\"http://localhost:8080\", viewer_id='client') \n\nmesh = trimesh.load('demosthenes.obj')\nverts, faces = mesh.vertices, mesh.faces\n\nviewer.add_mesh(\n    vertices=verts,\n    faces=faces,\n    name=\"Statue\"\n)\n\nviewer.hold() # prevent the script from terminating\n</code></pre> Done! For more elaborate examples, See the <code>Examples</code> tab, or:</p> <ul> <li>Importing Geometry</li> <li>Controls &amp; Callbacks</li> <li>Viewer State &amp; Events</li> </ul>"},{"location":"getting_started/#working-remotely-ssh","title":"Working remotely (SSH)","text":"<p>Panopti seamlessly integrates into remote work setups. Please refer to the Remote SSH page for details.</p>"},{"location":"materials/","title":"Material Types & Presets","text":"<p>Panopti offers several material types and presets for Mesh like objects through the ThreeJS material system. We encourage users to refer to ThreeJS documentation where appropriate.</p> <pre><code>import panopti\nfrom panopti.materials import (\n    MeshStandardMaterial,\n    MeshPhysicalMaterial,\n    MeshToonMaterial,\n    MeshBasicMaterial,\n    MeshNormalMaterial,\n    MeshDepthMaterial,\n)\nfrom panopti.materials import  MaterialPresets\n\nviewer = panopti.connect(server_url='http://localhost:8080', viewer_id='client')\n\n# ... load mesh here ...\n\n# Creating a standard material:\nmat = MeshStandardMaterial(\n    color=(1, 0, 0),\n    roughness=0.35, \n    metalness=0.05,\n    side='double'\n)\n\n# Or you can go for a material preset, e.g.\nmat = MaterialPresets.plastic\n\n# Create mesh with `material=mat`\nviewer.add_mesh(\n    name=f'MyMesh',\n    vertices=verts,\n    faces=faces,\n    material=mat\n)\n\nviewer.hold()\n</code></pre> Interaction of <code>color</code> and <code>vertex_colors</code> / <code>face_colors</code> <p>When adding mesh-like objects to your scene, be aware that ThreeJS will blend the material's <code>color</code> with <code>vertex_colors</code> or <code>face_colors</code> if they are specified. To avoid this, make sure you're using a purely white color <code>color = (1.0, 1.0, 1.0)</code>. For example:</p> <pre><code>mat = MaterialPresets.plastic\nmat.color = (1.0, 1.0, 1.0)\nviewer.add_mesh(\n    name=f'MyMesh',\n    vertices=verts,\n    faces=faces,\n    vertex_colors=my_vertex_colors,\n    material=mat\n)\n</code></pre> <p>For this reason, MaterialPresets uses white as the default color for all presets.</p>"},{"location":"materials/#material-types","title":"Material Types","text":"BaseMaterial <code>panopti.materials.base.BaseMaterial</code> MeshStandardMaterial <code>panopti.materials.MeshStandardMaterial</code> MeshPhysicalMaterial <code>panopti.materials.MeshPhysicalMaterial</code> MeshToonMaterial <code>panopti.materials.MeshToonMaterial</code> MeshNormalMaterial <code>panopti.materials.MeshNormalMaterial</code> MeshDepthMaterial <code>panopti.materials.MeshDepthMaterial</code>"},{"location":"materials/#basematerial","title":"BaseMaterial","text":"<p>Base class for all materials types with common properties. For details on the parameters listed below, refer to: https://threejs.org/docs/#api/en/materials/Material</p> <p>Supported parameters: <pre><code>- flat_shading: bool\n- color: RGB array [r,g,b] or hex string\n- opacity: float between 0 and 1\n- transparent: bool\n- alpha_test: float between 0 and 1\n- side: str, \"front\", \"back\", \"double\"\n- wireframe: bool\n- wireframe_linewidth: float\n- depth_test: bool\n- depth_write: bool\n- tone_mapped: bool\n</code></pre></p>"},{"location":"materials/#meshstandardmaterial","title":"MeshStandardMaterial","text":"<p>               Bases: <code>BaseMaterial</code></p> <p>Physically-based standard material with metallic-roughness workflow. For details on the parameters listed below, refer to: https://threejs.org/docs/#api/en/materials/MeshStandardMaterial</p> <p>Supported parameters: <pre><code>- roughness: float between 0 and 1\n- metalness: float between 0 and 1\n- emissive: RGB array [r,g,b] or hex string\n- emissive_intensity: float between 0 and 1\n</code></pre></p>"},{"location":"materials/#meshphysicalmaterial","title":"MeshPhysicalMaterial","text":"<p>               Bases: <code>BaseMaterial</code></p> <p>Extended physically-based material with additional properties for realistic rendering. For details on the parameters listed below, refer to: https://threejs.org/docs/#api/en/materials/MeshPhysicalMaterial</p> <p>Supported parameters: <pre><code>- roughness\n- metalness\n- emissive\n- emissive_intensity\n- reflectivity\n- sheen\n- sheen_roughness\n- sheen_color\n- specular_intensity\n- specular_color\n- ior\n- anisotropy\n- anisotropy_rotation\n- iridescence\n- iridescence_ior\n- iridescence_thickness_range\n- clearcoat\n- clearcoat_roughness\n- transmission\n- thickness\n- attenuation_distance\n- attenuation_color\n</code></pre></p>"},{"location":"materials/#meshtoonmaterial","title":"MeshToonMaterial","text":"<p>               Bases: <code>BaseMaterial</code></p> <p>Material for cel-shaded rendering. For details on the parameters listed below, refer to: https://threejs.org/docs/#api/en/materials/MeshToonMaterial</p> <p>Supported parameters: <pre><code>- emissive: RGB array [r,g,b] or hex string\n- emissive_intensity: float between 0 and 1\n</code></pre></p>"},{"location":"materials/#meshnormalmaterial","title":"MeshNormalMaterial","text":"<p>               Bases: <code>BaseMaterial</code></p> <p>Material for visualizing normal vectors - useful for debugging. See: https://threejs.org/docs/#api/en/materials/MeshNormalMaterial</p>"},{"location":"materials/#meshdepthmaterial","title":"MeshDepthMaterial","text":"<p>               Bases: <code>BaseMaterial</code></p> <p>Material for depth-based rendering - renders depth as grayscale. For details on the parameters listed below, refer to: https://threejs.org/docs/#api/en/materials/MeshDepthMaterial</p> <p>Supported parameters: <pre><code>- depth_packing: str, \"basic\" or \"rgba\"\n</code></pre></p>"},{"location":"materials/#material-presets","title":"Material Presets","text":"<p>We offer several customizable material presets that are applicable in most scenarios:</p> <p></p> <p>Example: <pre><code>from panopti.materials import MaterialPresets\n\nmat_plastic = MaterialPresets.plastic   # type: MeshStandardMaterial\nmat_glossy  = MaterialPresets.glossy    # type: MeshStandardMaterial\nmat_chalk   = MaterialPresets.chalk     # type: MeshStandardMaterial\nmat_marble  = MaterialPresets.marble    # type: MeshStandardMaterial\nmat_metal   = MaterialPresets.metal     # type: MeshPhysicalMaterial\nmat_flat    = MaterialPresets.flat      # type: MeshBasicMaterial\nmat_normals = MaterialPresets.normals   # type: MeshNormalMaterial\n\n# Customize their attributes to your liking, e.g. \n# make the material blue and half transparent:\nmat_plastic.color = \"#42a9f8\"\nmat_plastic.opacity = 0.5\nmat_plastic.transparent = True\n...\n</code></pre></p>"},{"location":"materials/#tips","title":"Tips","text":"Color-sensitive experiments"},{"location":"materials/#color-sensitive-experiments","title":"Color-sensitive experiments","text":"<p>In cases where color data should be displayed exactly as-is, you can disable shading and tonemapping. Consider using the following material setup:</p> <pre><code>from panopti.materials import MeshBasicMaterial\n\ncolor_safe_material = MeshBasicMaterial(\n    flat_shading=True,\n    tone_mapped=False\n)\n\nviewer.add_mesh(\n    name=f'MyMesh',\n    vertices=verts,\n    faces=faces,\n    material=color_safe_material\n)\n</code></pre>"},{"location":"remote_ssh/","title":"Remote SSH","text":"<p>Panopti seamlessly integrates into remote work setups. If you are using VSCode (e.g. with the <code>Remote - SSH</code> extension), then simply starting the server will automatically take care of port forwarding. If you are using SSH from a terminal, you can forward the Panopti port like so:</p> <p><code>ssh -L 8008:localhost:8080 user@remote.host</code></p> <p>Which pushes the remote <code>8080</code> port into the port <code>8008</code> locally, for example. Note that working remotely may incur additional latency in the viewer.</p>"},{"location":"todo/","title":"Todo","text":"<p>Misc:</p> <ul> <li>Fix <code>label</code> interface, right now you cannot specify text immediately on creation.</li> <li>If a <code>slider</code>'s name contains a space, then its corresponding textbox breaks.</li> <li>Make <code>Restart Script</code> button also call <code>Refresh Scene</code> to clean stale data.</li> <li>While a geometry is selected, calling e.g. <code>object.update(rotation=...)</code> will not update the entries in the transform panel (util you select the object again).</li> <li>Tune default lighting.</li> <li>Many object attributes are returned as a Python <code>List</code>, maybe we should prefer <code>np.array</code> by default?</li> </ul> <p>Small Features:</p> <ul> <li>Add callbacks to Plotly (not sure if possible)?</li> <li>Add more Event decorators: <ul> <li><code>object_update</code>: triggered when any object attribute is updated</li> <li><code>controls</code>: triggered when any control element is interacted with</li> <li><code>mouse</code>: expose a collection of mouse events through e.g. <code>events.mouse.[on_click, on_move, etc.]</code></li> </ul> </li> <li>Allow updating camera settings from user code.</li> </ul> <p>Larger Features:</p> <ul> <li>Add support for SDF rendering</li> <li>Add a comprehensive <code>.ini</code> settings file that can be modified directly, in Python, and through a UI modal in the frontend</li> </ul>"},{"location":"examples/controls_callbacks/","title":"Controls &amp; Callbacks","text":"<p>This example demonstrates a mix of user-defined control elements. Each control creates a small widget in the viewer while the corresponding callback stays entirely in Python. The code example below loads a mesh, modifies it using various controls, and displays a Plotly histogram showing relevant data. For a full list of supported controls, see Controls.</p> <pre><code>import panopti\nimport trimesh\nimport numpy as np\nimport plotly.graph_objects as go\nfrom panopti.utils import to_rgb\n\nviewer = panopti.connect(server_url=\"http://localhost:8080\", viewer_id='client')\nviewer.capture_prints(capture_stderr=True)\n\nmesh = trimesh.load('./examples/demosthenes.obj')\nverts, faces = mesh.vertices, mesh.faces\n\n# Add a mesh\nvertex_colors = to_rgb(verts[:, 1], cmap='viridis')\nviewer.add_mesh(\n    vertices=verts,\n    faces=faces,\n    name=\"Statue\",\n    vertex_colors=vertex_colors,\n)\n\n# --- Let's add some controls ---\n\n# On button press, randomly rescale our mesh\ndef callback_random_rotate(viewer):\n    random_rotation = np.random.uniform(0, 2 * np.pi, (3,))\n\n    yaxis_only = viewer.get('Y-axis Only').value() # read checkbox value\n    if yaxis_only: # zero out X,Z axes\n        random_rotation[[0, 2]] = 0\n\n    viewer.get('Statue').update(rotation=random_rotation)\n    plot_histogram(viewer) # update histogram\nviewer.button(callback=callback_random_rotate, name='Randomly rotate mesh')\n\n# Checkbox will control if we uniformly scale or not -- we can leave the callback blank\nviewer.checkbox(callback=None, name='Y-axis Only', initial=True)\n\n# Override mesh color using a color picker:\ndef callback_recolor_mesh(viewer, rgba):\n    mesh = viewer.get(\"Statue\")\n    if mesh is not None:\n        mat = mesh.material\n        mat.color = rgba[:3]\n        mat.opacity = rgba[3]\n        mat.transparency = mat.opacity &lt; 1.0\n\n        # Remove vertex colors and update material:\n        mesh.update(material=mat, vertex_colors=None)\n\nviewer.color_picker(callback=callback_recolor_mesh, name='Recolor Mesh', initial=(0.5, 0.5, 0.5, 1.0))\n\n# Slider that adds Gaussian noise to the mesh\ndef callback_add_noise(viewer, value):\n    noise = value * np.random.randn(*verts.shape)\n    new_verts = verts.copy() + noise\n    viewer.get('Statue').update(vertices=new_verts)\n    plot_histogram(viewer) # update histogram\nviewer.slider(callback=callback_add_noise, name='Gaussian Noise STD', min=0.0, max=0.2, initial=0.0, step=0.01)\n\n# Let's plot a histogram of the mesh vertex y-coordinates:\ndef plot_histogram(viewer):\n     # Get the y-coordinates of current mesh\n    data = viewer.get('Statue').viewer_verts[:,1]\n    counts, bins = np.histogram(data, bins=128)\n    bin_centers = 0.5 * (bins[:-1] + bins[1:])\n    widths = bins[1:] - bins[:-1]\n    fig = go.Figure(\n        go.Bar(\n            x=bin_centers,\n            y=counts,\n            width=widths,\n            marker=dict(\n                color=bin_centers,               # color by bin center\n                colorscale='Viridis',            # choose any Plotly colormap\n                showscale=False,                  # display the colorbar\n                colorbar=dict(title='Bin value'),\n                line=dict(width=0)\n            ),\n            showlegend=False\n        )\n    )\n    fig.update_layout(\n        margin=dict(l=0, r=0, t=20, b=0),\n        title_text='Histogram of Statue Y-coordinates',\n        xaxis_title='Statue Y-coordinates',\n        yaxis_title='Count',\n        showlegend=False,\n    )\n    fig.update_layout(title_font_size=12)\n    fig.update_layout(title_x=0.13, title_xanchor='left')\n    fig.update_xaxes(title_font_size=12, tickfont_size=8)\n    fig.update_yaxes(title_font_size=12, tickfont_size=8)\n    viewer.add_plotly(fig.to_plotly_json(), name='Histogram')\nplot_histogram(viewer)\n\nviewer.hold()\n</code></pre>"},{"location":"examples/importing_geometry/","title":"Importing geometry","text":"<p>Panopti supports a variety of geometric data structures, see for example Geometry \u2192 Mesh. The example below demonstrates how these structures can be added to your scene.</p> <pre><code>import panopti\nimport trimesh\nimport numpy as np\nfrom panopti.utils import to_rgb\n\nviewer = panopti.connect(server_url='http://localhost:8080', viewer_id='client')\n\nmesh = trimesh.load('./examples/demosthenes.obj')\nverts, faces = mesh.vertices, mesh.faces\nverts = np.ascontiguousarray(verts, dtype=np.float32)\nfaces = np.ascontiguousarray(faces, dtype=np.int32)\nnormals = np.ascontiguousarray(mesh.vertex_normals, dtype=np.float32)\nverts = verts - verts.mean(axis=0, keepdims=True)  # Center the mesh\n\n### Add mesh with vertex colors\nvertex_colors = to_rgb(verts[:, 1], cmap='viridis')\nviewer.add_mesh(\n    vertices=verts,\n    faces=faces,\n    name=\"StatueMesh\",\n    vertex_colors=vertex_colors,\n)\n\n### Add Point cloud -- reuse vertex_colors\npoints = verts.copy()\npoints[:,0] += 2\nviewer.add_points(\n    points=points,\n    name=\"StatuePoints\",\n    colors=vertex_colors,\n    size=0.015,\n)\n\n### Add arrows pointing to another point cloud\npoints2 = points + (0.8, 0.8, -1.5)\nrandom_subset = np.random.choice(points.shape[0], size=points.shape[0] // 128, replace=False)\nviewer.add_points(\n    points=points2[random_subset],\n    name=\"PointsSubset\",\n    colors=vertex_colors[random_subset],\n    size=0.05,\n)\n\nviewer.add_arrows(\n    starts=points2[random_subset],\n    ends=points[random_subset],\n    name=\"Arrows\",\n    color=(0.01, 0.01, 0.01),\n    width=0.01,\n)\n\ndef whacky_transform(vertices, normals, t):\n    # 1) swirl around Y: angle = t*2\u03c0 * radius\n    radii  = np.linalg.norm(vertices, axis=1)\n    angles = radii * (t * 2*np.pi)\n    cosA   = np.cos(angles)[:,None]\n    sinA   = np.sin(angles)[:,None]\n    x, y, z = vertices[:,0:1], vertices[:,1:2], vertices[:,2:3]\n\n    x_sw = x * cosA - z * sinA\n    z_sw = x * sinA + z * cosA\n    verts_swirl = np.concatenate([x_sw, y, z_sw], axis=1)\n\n    # 2) pulsate along normals: sin(frequency*radius + phase) * amplitude\n    freq      = 6.0                   # number of ripples\n    amp_base  = 0.2                   # max offset\n    phase     = t * np.pi             # phase shift\n    offsets   = np.sin(radii * freq + phase) * amp_base * t\n    verts_out = verts_swirl + normals * offsets[:,None]\n\n    return verts_out\n\n# bake whacky animation:\nverts_animation = []\nfor t in np.linspace(0, 1, 50):\n    temp_verts = whacky_transform(verts.copy(), normals, t)\n    verts_animation.append(temp_verts)\nverts_animation = np.stack(verts_animation)\n# boomerang the animation:\nverts_animation = np.concatenate([verts_animation, verts_animation[::-1]], axis=0)\nviewer.add_animated_mesh(\n    vertices=verts_animation,\n    faces=faces,\n    name=\"WhackyAnimation\",\n    framerate=24,\n    vertex_colors=vertex_colors,\n    position=(-2, 0, 0) # move to the left\n)\n\nviewer.hold()\n</code></pre>"},{"location":"examples/viewer_state_events/","title":"Viewer State & Events","text":"<p>Panopti offers various mechanisms for reading and modifying the viewer's state.</p>"},{"location":"examples/viewer_state_events/#geometry","title":"Geometry","text":"<p>All geometric objects support the following get, update, delete functions:</p> <pre><code>import panopti\nviewer = panopti.connect(...)\nviewer.add_mesh(name='MyMesh', ...)\n\n# Get mesh:\nmymesh = viewer.get('MyMesh')\n\n# Update mesh vertices, vertex_colors, or any other attributes:\nmymesh.update(vertices=..., vertex_colors=...)\n\n# Delete mesh:\nmymesh.delete()\n</code></pre>"},{"location":"examples/viewer_state_events/#camera","title":"Camera","text":"<p>See also: Camera</p> <p>You can directly get and set camera attributes by doing: <pre><code>import panopti\nviewer = panopti.connect(...)\n\n# get current camera state as dict\ncamera_data = viewer.camera()\n\n# set camera attributes manually\nviewer.set_camera(\n    position=(0.0, 5.0, 0.0),\n    target=(0.0, 0.0, 0.0),\n    projection_mode='orthographic'\n)\n\n# standard look_at function:\nviewer.look_at(\n    position=(-2.0, 1.0, 3.0),\n    target=(0.0, -2.0, 0.0),\n)\n\n@viewer.events.camera()\ndef my_camera_event(viewer, camera_info):\n    # this function is triggered when the viewer camera is manipulated\n    print('Camera was moved to ', camera_info.position)\n\nviewer.hold()\n</code></pre></p> ViewerClient.camera() ViewerClient.set_camera() ViewerClient.look_at() <code>@viewer.events.camera()</code>"},{"location":"examples/viewer_state_events/#camera_1","title":"camera","text":"<p>Return the current camera parameters as a dictionary containing:</p> key meaning type position camera world coords ndarray rotation camera XYZ euler rotation ndarray quaternion camera rotation as quaternion ndarray up camera up-vector ndarray target point the camera is looking at ndarray fov vertical field-of-view (degrees) float near near-plane distance float far far-plane distance float aspect viewport aspect ratio (w / h) float projection_mode 'perspective' or 'orthographic' str"},{"location":"examples/viewer_state_events/#set_camera","title":"set_camera","text":"<p>Update the viewer camera.</p> <p>Accepts the same keyword arguments that <code>camera</code> returns. Any provided values will overwrite the current camera state.</p>"},{"location":"examples/viewer_state_events/#look_at","title":"look_at","text":"<p>Position the camera and look at <code>target</code>.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>(list, ndarray)</code> <p>Camera position in world coordinates.</p> required <code>target</code> <code>(list, ndarray)</code> <p>World coordinate the camera should look at.</p> required"},{"location":"examples/viewer_state_events/#event-decorator","title":"event decorator","text":"<p>The <code>camera</code> event is triggered when the user manipulates the viewer  camera (e.g. orbit, pan, zoom). This event provides a <code>CameraInfo</code> object  containing information about the camera's current state.</p> <p>Parameters:</p> Name Type Description Default <code>throttle</code> <code>int</code> <p>Throttle interval in milliseconds. If provided,  the callback will only be called at most once per throttle interval.</p> <code>None</code> <p>Example usage: <pre><code>@viewer.events.camera()\ndef camera_event(viewer, camera_info):\n    print('Camera was updated!')\n    # swivel scene mesh to always face the camera (in Y-axis):\n    mesh = viewer.get('myMesh')\n    mx, my, mz = mesh.position\n    cx, cy, cz = camera_info.position  # dot-access notation\n    yaw = math.atan2(cx - mx, cz - mz)\n    mesh.rotation = [0, yaw, 0]\n    mesh.update(rotation=[0, yaw, 0])\n\n# Or with throttling (100ms interval)\n@viewer.events.camera(throttle=100)\ndef throttled_camera_event(viewer, camera_info):\n    print('Throttled camera update!')\n</code></pre> <code>camera_info</code> is a <code>CameraInfo</code> object with the following attributes:</p> attribute meaning type position camera world coords ndarray rotation camera XYZ euler rotation ndarray quaternion camera rotation as quaternion ndarray up camera up-vector ndarray target point the camera is looking at ndarray fov vertical field-of-view (degrees) float near near-plane distance float far far-plane distance float aspect viewport aspect ratio (w / h) float projection_mode 'perspective' or 'orthographic' str"},{"location":"examples/viewer_state_events/#transformations","title":"Transformations","text":"<p>See also: Transformations &amp; Gizmo</p> <p>Panopti offers interactive mechanisms for translating, rotating, and scaling geometries through the transformation panel and through gizmos. To open the transformation panel, simply select a scene object. For the gizmo tool, see the toolbar. The transformated state of scene objects can be accessed by your code through property fields of scene geometries.</p> <p>Example: <pre><code>import panopti\nimport numpy as np\nviewer = panopti.connect(server_url=\"http://localhost:8080\", viewer_id=\"client\")\n\n# ... load triangle mesh vertices / faces ...\n\nviewer.add_mesh(vertices=vertices, faces=faces, name=\"MyMesh\")\n\n# Add a button that reads off the mesh's current transformation:\ndef my_button_callback(viewer):\n    mesh = viewer.get('MyMesh')\n\n    # request MyMesh's 4x4 transformation matrix:\n    trans_mat = mesh.trans_mat\n\n    # or directly access the transformed vertex tensor:\n    transformed_verts = mesh.viewer_verts\n\n    # ... do something here ...\n\nviewer.button(callback=my_button_callback, name='MyButton')\n\nviewer.hold() # prevent script from terminating\n</code></pre></p> <p>Each geometry type exposes helper attributes for retrieving the object's current 4x4 transformation matrix and associated quantities. For example, for Meshes and AnimatedMeshes objects, we offer: </p> Mesh.trans_mat Mesh.viewer_verts <p>See other geometry types for related functions, e.g. Points.</p>"},{"location":"examples/viewer_state_events/#trans_mat","title":"trans_mat","text":"<p>Fetches the objects current 4x4 transformation matrix. <pre><code>viewer.get('MyObject').trans_mat\n</code></pre></p>"},{"location":"examples/viewer_state_events/#viewer_verts","title":"viewer_verts","text":"<p>Fetches the objects current vertices with <code>trans_mat</code> pre-applied <pre><code>viewer.get('MyObject').viewer_verts\n</code></pre></p>"},{"location":"examples/viewer_state_events/#events","title":"Events","text":"<p>Panopti exposes several event callbacks through Python decorators, which are accessible through <code>viewer.events</code>, the usage pattern looks like: <pre><code>import panopti\nviewer = panopti.connect(server_url=\"http://localhost:8080\", viewer_id='client')\n\n@viewer.events.camera()\ndef my_camera_event(viewer, camera_info):\n    # this function is triggered when the viewer camera is manipulated\n    ...\n</code></pre> These callbacks give user code access to various viewer events, see Events for a list of supported decorators.</p>"},{"location":"geometry/animated_mesh/","title":"Animated Meshes","text":"<p>The Panopti <code>AnimatedMesh</code> object represents a temporally evolving triangular surface mesh. To add an animated mesh to your scene: <pre><code>import panopti\nimport trimesh # just for io\nimport numpy as np\n\nviewer = panopti.connect(server_url=\"http://localhost:8080\", viewer_id='client')\n\nmesh = trimesh.load('mesh.obj')\nverts = mesh.vertices   # (V, 3) ndarray\nfaces = mesh.faces      # (F, 3) ndarray \n\n# Create simple animation of sliding mesh\nnum_frames = 60\ntemporal_offset = np.linspace([0, 0, 0], [1, 0, 0], num=num_frames)[:, None, :]\nverts_animation = np.repeat(verts[np.newaxis], repeats=num_frames, axis=0)\nverts_animation += temporal_offset\n\nviewer.add_animated_mesh(\n    vertices=verts_animation,\n    faces=faces,\n    name=\"MyAnimatedMesh\",\n    framerate=24\n)\n</code></pre></p> BaseViewer.add_animated_mesh AnimatedMesh.update(**kwargs) AnimatedMesh.delete() AnimatedMesh.trans_mat <code>property</code> AnimatedMesh.viewer_verts <code>property</code>"},{"location":"geometry/animated_mesh/#add_animated_mesh","title":"add_animated_mesh","text":"<p>Adds an AnimatedMesh object to the viewer.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>ndarray</code> <p>(T, V, 3) array of vertex coordinates for each frame.</p> required <code>faces</code> <code>ndarray</code> <p>(F, 3) array of face indices.</p> required <code>name</code> <code>str</code> <p>Name for the animated mesh.</p> required <code>framerate</code> <code>float</code> <p>Framerate for the animation.</p> <code>24.0</code> <code>visible</code> <code>bool</code> <p>Whether the mesh is visible.</p> <code>True</code> <code>position</code> <code>Union[Tuple[float, float, float], ndarray]</code> <p>Position of the mesh (XYZ).</p> <code>(0, 0, 0)</code> <code>rotation</code> <code>Union[Tuple[float, float, float], ndarray]</code> <p>Rotation of the mesh (XYZ).</p> <code>(0, 0, 0)</code> <code>scale</code> <code>Union[Tuple[float, float, float], ndarray]</code> <p>Scale of the mesh in (XYZ).</p> <code>(1.0, 1.0, 1.0)</code> <code>color</code> <code>Union[Tuple[float, float, float], ndarray]</code> <p>Uniform RGB color of the mesh.</p> <code>(1.0, 1.0, 1.0)</code> <code>vertex_colors</code> <code>ndarray</code> <p>(V, 3) array of vertex colors.</p> <code>None</code> <code>face_colors</code> <code>ndarray</code> <p>(F, 3) array of face colors.</p> <code>None</code> <code>material</code> <code>Optional[Any]</code> <p>Panopti material object.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>AnimatedMesh</code> <code>AnimatedMesh</code> <p>The created panopti animated mesh object.</p>"},{"location":"geometry/animated_mesh/#update","title":"update","text":"<p>Updates this animated mesh's attributes and propagate updates to the viewer.</p> <p>Example: <pre><code>animated_mesh = viewer.get('MyAnimatedMesh')\nanimated_mesh.update(vertices=new_verts, material=new_material)\n</code></pre></p>"},{"location":"geometry/animated_mesh/#delete","title":"delete","text":"<p>Deletes this animated mesh from the viewer.</p>"},{"location":"geometry/animated_mesh/#trans_mat","title":"trans_mat","text":"<p>Returns the 4x4 transformation matrix corresponding to the object's position, rotation, and scale in the viewer.</p>"},{"location":"geometry/animated_mesh/#viewer_verts","title":"viewer_verts","text":"<p>Returns the Mesh's vertices under the transformation given by <code>trans_mat</code>.</p>"},{"location":"geometry/arrows/","title":"Arrows","text":"<p>The Panopti <code>Arrows</code> object represents a collection of floating arrows defined by an array of starting points and ending points. To add arrows to your scene: <pre><code>import panopti\nimport numpy as np\n\nviewer = panopti.connect(server_url=\"http://localhost:8080\", viewer_id='client')\n\nstart_points = np.random.randn(64, 3)\nend_points = start_points.clone()\nend_points[:, 0] += 3.0\n\nviewer.add_arrows(\n    starts=start_points,\n    ends=end_points,\n    name='MyArrows',\n    color=(0.5, 0.5, 0.5),\n    width=0.02\n)\n</code></pre></p> BaseViewer.add_arrows Arrows.update(**kwargs) Arrows.delete() Arrows.trans_mat <code>property</code> Arrows.viewer_starts <code>property</code> Arrows.viewer_ends <code>property</code>"},{"location":"geometry/arrows/#add_arrows","title":"add_arrows","text":"<p>Adds an Arrows object to the viewer.</p> <p>Parameters:</p> Name Type Description Default <code>starts</code> <code>ndarray</code> <p>(N, 3) array of start points for the arrows.</p> required <code>ends</code> <code>ndarray</code> <p>(N, 3) array of end points for the arrows.</p> required <code>name</code> <code>str</code> <p>Name for the arrows object.</p> required <code>color</code> <code>Union[Tuple[float, float, float], ndarray]</code> <p>(N, 3) or (3,) array of RGB colors for the arrows.</p> <code>(0, 0, 0)</code> <code>width</code> <code>float</code> <p>Width of the arrows.</p> <code>0.01</code> <code>visible</code> <code>bool</code> <p>Whether the arrows are visible.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Opacity of the arrows.</p> <code>1.0</code> <p>Returns:</p> Name Type Description <code>Arrows</code> <code>Arrows</code> <p>The created panopti arrows object.</p>"},{"location":"geometry/arrows/#update","title":"update","text":"<p>Updates this arrow's attributes and propagate updates to the viewer.</p> <p>Example: <pre><code>arrows = viewer.get('MyArrows')\narrows.update(width=0.03, color=new_color)\n</code></pre></p>"},{"location":"geometry/arrows/#delete","title":"delete","text":"<p>Deletes this arrow from the viewer.</p>"},{"location":"geometry/arrows/#trans_mat","title":"trans_mat","text":"<p>Returns the 4x4 transformation matrix corresponding to the object's position, rotation, and scale in the viewer.</p>"},{"location":"geometry/arrows/#viewer_starts","title":"viewer_starts","text":"<p>Returns the Arrow's <code>starts</code> attribute under the transformation given by <code>trans_mat</code>.</p>"},{"location":"geometry/arrows/#viewer_ends","title":"viewer_ends","text":"<p>Returns the Arrow's <code>ends</code> attribute under the transformation given by <code>trans_mat</code>.</p>"},{"location":"geometry/mesh/","title":"Meshes","text":"<p>The Panopti <code>Mesh</code> object represents a triangular surface mesh. To add a mesh to your scene: <pre><code>import panopti\nimport trimesh # just for io\nimport numpy as np\n\nviewer = panopti.connect(server_url=\"http://localhost:8080\", viewer_id='client')\n\nmesh = trimesh.load('mesh.obj')\nverts = mesh.vertices   # (V, 3) ndarray\nfaces = mesh.faces      # (F, 3) ndarray \n\nviewer.add_mesh(\n    vertices=verts,\n    faces=faces,\n    name=\"MyMesh\"\n)\n</code></pre></p> BaseViewer.add_mesh Mesh.update(**kwargs) Mesh.delete() Mesh.trans_mat <code>property</code> Mesh.viewer_verts <code>property</code>"},{"location":"geometry/mesh/#add_mesh","title":"add_mesh","text":"<p>Adds a Mesh object to the viewer.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>ndarray</code> <p>(V, 3) array of vertex coordinates.</p> required <code>faces</code> <code>ndarray</code> <p>(F, 3) array of face indices.</p> required <code>name</code> <code>str</code> <p>Name for the mesh.</p> required <code>visible</code> <code>bool</code> <p>Whether the mesh is visible.</p> <code>True</code> <code>position</code> <code>Union[Tuple[float, float, float], ndarray]</code> <p>Position of the mesh (XYZ).</p> <code>(0, 0, 0)</code> <code>rotation</code> <code>Union[Tuple[float, float, float], ndarray]</code> <p>Rotation of the mesh (XYZ).</p> <code>(0, 0, 0)</code> <code>scale</code> <code>Union[Tuple[float, float, float], ndarray]</code> <p>Scale of the mesh in (XYZ).</p> <code>(1.0, 1.0, 1.0)</code> <code>vertex_colors</code> <code>ndarray</code> <p>(V, 3) array of vertex colors.</p> <code>None</code> <code>face_colors</code> <code>ndarray</code> <p>(F, 3) array of face colors.</p> <code>None</code> <code>material</code> <code>Optional[Any]</code> <p>Panopti material object.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Mesh</code> <code>Mesh</code> <p>The created panopti mesh object.</p>"},{"location":"geometry/mesh/#update","title":"update","text":"<p>Updates this mesh's attributes and propagate updates to the viewer.</p> <p>Example: <pre><code>mesh = viewer.get('MyMesh')\nmesh.update(vertices=new_verts, material=new_material)\n</code></pre></p>"},{"location":"geometry/mesh/#delete","title":"delete","text":"<p>Deletes this mesh from the viewer.</p>"},{"location":"geometry/mesh/#trans_mat","title":"trans_mat","text":"<p>Returns the 4x4 transformation matrix corresponding to the object's position, rotation, and scale in the viewer.</p>"},{"location":"geometry/mesh/#viewer_verts","title":"viewer_verts","text":"<p>Returns the Mesh's vertices under the transformation given by <code>trans_mat</code>.</p>"},{"location":"geometry/point_cloud/","title":"Point Clouds","text":"<p>The Panopti <code>Points</code> object represents a point cloud. To add a point cloud to your scene: <pre><code>import panopti\nimport numpy as np\n\nviewer = panopti.connect(server_url=\"http://localhost:8080\", viewer_id='client')\n\npoints = np.random.randn(128, 3)\n\nviewer.add_points(\n    points=points,\n    name=\"MyPointCloud\",\n    colors=(0.5, 0.5, 0.5),\n    size=0.01\n)\n</code></pre></p> BaseViewer.add_points Points.update(**kwargs) Points.delete() Points.trans_mat <code>property</code> Points.viewer_points <code>property</code>"},{"location":"geometry/point_cloud/#add_points","title":"add_points","text":"<p>Adds a Point Cloud object to the viewer.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>ndarray</code> <p>(N, 3) array of point coordinates.</p> required <code>name</code> <code>str</code> <p>Name for the points object.</p> required <code>colors</code> <code>Union[Tuple[float, float, float], ndarray]</code> <p>(N, 3) or (3,) array of RGB colors for the points.</p> <code>(0.5, 0.5, 0.5)</code> <code>size</code> <code>float</code> <p>Size of the points.</p> <code>0.01</code> <code>visible</code> <code>bool</code> <p>Whether the points are visible.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Opacity of the points.</p> <code>1.0</code> <p>Returns:</p> Name Type Description <code>Points</code> <code>Points</code> <p>The created panopti points object.</p>"},{"location":"geometry/point_cloud/#update","title":"update","text":"<p>Updates this point cloud's attributes and propagate updates to the viewer.</p> <p>Example: <pre><code>points = viewer.get('MyPoints')\npoints.update(size=0.02, points=new_points)\n</code></pre></p>"},{"location":"geometry/point_cloud/#delete","title":"delete","text":"<p>Deletes this point cloud from the viewer.</p>"},{"location":"geometry/point_cloud/#trans_mat","title":"trans_mat","text":"<p>Returns the 4x4 transformation matrix corresponding to the object's position, rotation, and scale in the viewer.</p>"},{"location":"geometry/point_cloud/#viewer_points","title":"viewer_points","text":"<p>Returns the point cloud points under the transformation given by <code>trans_mat</code>.</p>"},{"location":"viewer/camera/","title":"Camera","text":"<p>You can directly get and set camera attributes by using member functions on a viewer object: <pre><code>import panopti\nviewer = panopti.connect(...)\n\n# get current camera state as dict\ncamera_data = viewer.camera() \n\n# set camera attributes manually\nviewer.set_camera(\n    position=(0.0, 5.0, 0.0),\n    target=(0.0, 0.0, 0.0),\n    projection_mode='orthographic'\n)\n\n# standard look_at function:\nviewer.look_at(\n    position=(-2.0, 1.0, 3.0),\n    target=(0.0, -2.0, 0.0),\n)\n\n# this function is triggered when the viewer camera is manipulated\n@viewer.events.camera()\ndef my_camera_event(viewer, camera_info):\n    print('Camera was moved to ', camera_info.position)\n\nviewer.hold()\n</code></pre></p> ViewerClient.camera ViewerClient.set_camera ViewerClient.look_at Camera Event Decorator <code>@viewer.events.camera()</code>"},{"location":"viewer/camera/#camera","title":"camera","text":"<p>Return the current camera parameters as a dictionary containing:</p> key meaning type position camera world coords ndarray rotation camera XYZ euler rotation ndarray quaternion camera rotation as quaternion ndarray up camera up-vector ndarray target point the camera is looking at ndarray fov vertical field-of-view (degrees) float near near-plane distance float far far-plane distance float aspect viewport aspect ratio (w / h) float projection_mode 'perspective' or 'orthographic' str"},{"location":"viewer/camera/#set_camera","title":"set_camera","text":"<p>Update the viewer camera.</p> <p>Accepts the same keyword arguments that <code>camera</code> returns. Any provided values will overwrite the current camera state.</p>"},{"location":"viewer/camera/#look_at","title":"look_at","text":"<p>Position the camera and look at <code>target</code>.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>(list, ndarray)</code> <p>Camera position in world coordinates.</p> required <code>target</code> <code>(list, ndarray)</code> <p>World coordinate the camera should look at.</p> required"},{"location":"viewer/camera/#event-decorator","title":"event decorator","text":"<p>The <code>camera</code> event is triggered when the user manipulates the viewer  camera (e.g. orbit, pan, zoom). This event provides a <code>CameraInfo</code> object  containing information about the camera's current state.</p> <p>Parameters:</p> Name Type Description Default <code>throttle</code> <code>int</code> <p>Throttle interval in milliseconds. If provided,  the callback will only be called at most once per throttle interval.</p> <code>None</code> <p>Example usage: <pre><code>@viewer.events.camera()\ndef camera_event(viewer, camera_info):\n    print('Camera was updated!')\n    # swivel scene mesh to always face the camera (in Y-axis):\n    mesh = viewer.get('myMesh')\n    mx, my, mz = mesh.position\n    cx, cy, cz = camera_info.position  # dot-access notation\n    yaw = math.atan2(cx - mx, cz - mz)\n    mesh.rotation = [0, yaw, 0]\n    mesh.update(rotation=[0, yaw, 0])\n\n# Or with throttling (100ms interval)\n@viewer.events.camera(throttle=100)\ndef throttled_camera_event(viewer, camera_info):\n    print('Throttled camera update!')\n</code></pre> <code>camera_info</code> is a <code>CameraInfo</code> object with the following attributes:</p> attribute meaning type position camera world coords ndarray rotation camera XYZ euler rotation ndarray quaternion camera rotation as quaternion ndarray up camera up-vector ndarray target point the camera is looking at ndarray fov vertical field-of-view (degrees) float near near-plane distance float far far-plane distance float aspect viewport aspect ratio (w / h) float projection_mode 'perspective' or 'orthographic' str"},{"location":"viewer/console_mirroring/","title":"Console Mirroring","text":"<p> Panopti has a built-in floating console that relays your script's prints/errors directly to the viewer, making it easy to debug without switching between windows. The console also supports colored text. To propagate your script's print stream to the viewer, simply call <code>capture_prints()</code> like so:</p> <pre><code>import panopti\nviewer = panopti.connect(server_url=\"http://localhost:8080\", viewer_id='client')\nviewer.capture_prints(capture_stderr=True)\n\nprint(\"This message will appear in the viewer!\")\n\n# Print with custom color tags:\nprint(\"[COLOR:red]This is red text[/COLOR]\")\nprint(\"[COLOR:magenta]This is magenta text[/COLOR]\")\nprint(\"Here is [COLOR:green]mixed[/COLOR] text [COLOR:blue]coloring[/COLOR]!\")\n\n# Print directly to the viewer console (without printing locally):\nviewer.print_colored(\"This is a yellow message\", \"yellow\")\n\n# Or with ANSI color tags:\nprint(\"\\033[32mThis is a green message using ANSI codes\\033[0m\")\nprint(\"\\033[31mThis is a red message using ANSI codes\\033[0m\")\nprint(\"\\033[33mThis is a yellow message using ANSI codes\\033[0m\")\nprint(\"\\033[34mThis is a blue message using ANSI codes\\033[0m\")\nprint(\"\\033[35mThis is a magenta message using ANSI codes\\033[0m\")\n\nviewer.hold()\n</code></pre> <p>The propagated print statements are accessible in the viewer's <code>Console</code>, which can be opened by clicking the following button: </p> <p></p>"},{"location":"viewer/console_mirroring/#available-colors","title":"Available Colors","text":"<p>The custom <code>[COLOR:&lt;color&gt;] ... [/COLOR]</code> tags support the following colors:</p> \u25a0<code>white</code> \u25a0<code>red</code> \u25a0<code>green</code> \u25a0<code>yellow</code> \u25a0<code>blue</code> \u25a0<code>magenta</code> \u25a0<code>cyan</code> \u25a0<code>black</code> \u25a0<code>bright-white</code> \u25a0<code>bright-red</code> \u25a0<code>bright-green</code> \u25a0<code>bright-yellow</code> \u25a0<code>bright-blue</code> \u25a0<code>bright-magenta</code> \u25a0<code>bright-cyan</code> \u25a0<code>bright-black</code> <p>Or the corresponding ANSI tags:</p> ANSI color tags Printing to Panopti console only - <code>viewer.print_colored(...)</code>"},{"location":"viewer/console_mirroring/#ansi-color-tags","title":"ANSI color tags","text":"<p>Example: <code>print(\"\\033[32mThis is a green message\\033[0m\")</code></p> ANSI Code Color <code>\\033[37m</code> white <code>\\033[31m</code> red <code>\\033[32m</code> green <code>\\033[33m</code> yellow <code>\\033[34m</code> blue <code>\\033[35m</code> magenta <code>\\033[36m</code> cyan <code>\\033[30m</code> black <code>\\033[97m</code> bright-white <code>\\033[91m</code> bright-red <code>\\033[92m</code> bright-green <code>\\033[93m</code> bright-yellow <code>\\033[94m</code> bright-blue <code>\\033[95m</code> bright-magenta <code>\\033[96m</code> bright-cyan <code>\\033[90m</code> bright-black"},{"location":"viewer/console_mirroring/#print_colored","title":"print_colored","text":"<p>Print colored text directly to the viewer console.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to print</p> required <code>color</code> <code>str</code> <p>Optional color name: white, red, green, yellow, blue, magenta,     bright-red, bright-green, bright-yellow, bright-blue, bright-magenta</p> <code>None</code> <code>end</code> <code>str</code> <p>The end character to print (default is <code>\\n</code>)</p> <code>'\\n'</code>"},{"location":"viewer/customization/","title":"Customization","text":"<p>Panopti exposes several customizable settings through a <code>TOML</code> configuration file, which allows you to change default behavior and appearance of the viewer. When starting your server, simply specify the optional flag <code>--config /path/to/config.toml</code> like so:</p> <pre><code>python -m panopti.run_server --host localhost --port 8080 --config .panopti.toml\n</code></pre> <p>Below we provide a full default configuration file with annotated entries. Note that you may specify a subset of these properties, the rest will be automatically filled by defaults. If a config file is not provided, these values will be used.</p> <p>To see updates, restart your Panopti server and refresh the browser tab.</p> <pre><code># Panopti configuration file: .pantop.toml\n\ntitle = \"Panopti\"                       # Title displayed in ui panel\n\n[viewer.tools]\ngrid.enabled = true                     # Enable grid helper\naxes.enabled = true                     # Enable axes helper\n\n[viewer.renderer]\nmax-fps = 60                            # Renderer max fps (see below)\npower-preference = \"default\"            # ThreeJS.WebGLRenderer opt: [default, low-power, high-performance]\n\n# Custom lights (see note below)\nlight-key     = { type = \"directional\", position = [10, 15, 10], target = [0, 0, 0], color = \"#ffffff\", intensity = 2.3, castShadow = false }\nlight-fill    = { type = \"directional\", position = [-20, 5, -10], target = [0, 0, 0], color = \"#ffffff\", intensity = 2.0, castShadow = false }\nlight-ambient = { type = \"ambient\", color = \"#ffffff\", intensity = 1.0 }\n\n[viewer.theme]\nprimary-color = \"#4361ee\"               # Color for general ui elements\nprimary-hover = \"#3a56d4\"               # Color on element hover\nbackground-color = \"#f0f0f0\"            # Bg color of renderer\nbackground-color-dark = \"#2d3142\"       # Dark mode bg color ^^^\npanel-bg = \"#ffffff\"                    # UI panel bg color\ntext-color = \"#333333\"\nbutton-active: \"#38b000\"                # Toggled button color\ndark-mode = false                       # Toggle dark mode\n\n[viewer.camera]                         # Camera settings, see docs page\nposition = [5, 5, 5]\ntarget = [0, 0, 0]\nfov = 50\nnear = 0.1\nfar = 1000\nprojection = \"perspective\"\n\n[viewer.ui]\npanel.controls.collapsed = false        # Collapse UI panel\npanel.layers.collapsed = false          # Collapse layers panel\nconsole.enabled = false                 # Opens the console widget\ninfobar.enabled = true                  # Hides information bar\n\n# Low-level viewer settings\n[viewer.debounce]                       # Debounce timers (in ms)\nslider = 25                             # Slider elements\ntransform = 25                          # Object transformation event\ncamera = 25                             # Camera change event\n</code></pre>"},{"location":"viewer/customization/#tips","title":"Tips","text":"Max FPS &amp; Power Mode Debounce Lighting Setup"},{"location":"viewer/customization/#max-fps-power-preference","title":"max-fps &amp; power-preference","text":"<p>Panopti's renderer defaults to 60 fps and can be changed through the <code>max-fps</code> field above. If developing on a laptop (where battery life is a concern), consider lowering this value. Additionally, some monitors support higher refresh rates, e.g. 144 fps.</p> <p>We also expose the WebGL power preference attribute through <code>power-preference = \"default\"</code> above. See: https://registry.khronos.org/webgl/specs/latest/1.0/#5.2. Other options include <code>\"low-power\"</code> and <code>\"high-performance\"</code>.</p> <p>Note that Panopti has largely been tested on the default power setting, your mileage may vary.</p>"},{"location":"viewer/customization/#debounce","title":"debounce","text":"<p>For scenes that include heavy callbacks on \"continuous\" control elements (e.g. sliders), you may consider increasing the relevant debounce timers under the <code>viewer.debounce</code> group. This will prevent your script from being spammed by such elements.</p>"},{"location":"viewer/customization/#light","title":"light","text":"<p>Panopti's viewport lighting can be customized through special <code>light-&lt;...&gt;</code> keys under <code>[viewer.renderer]</code>. Please see the above config example for supported light parameters. Supported light types are: <code>[directional, ambient, point]</code></p>"},{"location":"viewer/inspection_tool/","title":"Inspection Tool","text":"<p> The inspection tool in Panopti allows you to interactively inspect the geometric data structures. For meshes-like objects this tool displays the selected face index and corresponding vertex indices around the face, for point clouds the selected point index is displayed.</p>"},{"location":"viewer/inspection_tool/#example-using-inspection-events","title":"Example: Using Inspection Events","text":"<p>You can react to inspection events in your Python code using the <code>@viewer.events.inspect()</code> decorator. This allows you to trigger custom logic whenever a user inspects an object in the viewer.</p> <pre><code>import panopti\nviewer = panopti.connect(...)\n\n# ... your scene ...\n\n@viewer.events.inspect()\ndef inspect_event(viewer, inspect_info):\n    print(f\"User clicked on a {inspect_info.object_type} object.\")\n    if inspect_info.object_type in ['mesh', 'animated_mesh']:\n        # inspect_result is MeshInspectResult\n        print('Selected face index:', inspect_info.inspect_result.face_index)\n        print('Selected vertex indices:', inspect_info.inspect_result.vertex_indices)\n    elif inspect_info.object_type == 'points':\n        # inspect_result is PointCloudInspectResult\n        print('Selected point index:', inspect_info.inspect_result.point_index)\n\nviewer.hold()\n</code></pre> Inspect - <code>@viewer.events.inspect()</code>"},{"location":"viewer/inspection_tool/#inspection-event","title":"Inspection Event","text":"<p>The <code>inspect</code> event is triggered when the inspection tool is used in the viewer (e.g. when clicking on a mesh to inspect its local vertex indices). Example usage: <pre><code>@viewer.events.inspect()\ndef inspect_event(viewer, inspect_info):\n    print(f\"User clicked on a {inspect_info.object_type} object.\")\n    if inspect_info.object_type == 'mesh':\n        print('Selected face index: ', inspect_info.inspect_result.face_index)\n</code></pre> <code>inspect_info</code> is an <code>InspectInfo</code> object with the following attributes:</p> attribute meaning type object_name <code>name</code> attribute of selected object str object_type type of Panopti object selected (e.g., <code>'mesh'</code>, <code>'points'</code>) str world_coords XYZ world coordinates of the pick point ndarray screen_coords integer pixel coordinates of the pick point ndarray inspect_result geometry-specific data at the pick point:Mesh / AnimatedMesh: <code>MeshInspectResult</code> holding <code>face_index</code> and <code>vertex_indices</code>PointCloud: <code>PointCloudInspectResult</code> holding <code>point_index</code> Union[MeshInspectResult, PointCloudInspectResult]"},{"location":"viewer/screenshots/","title":"Screenshots","text":"<p>With Panopti you can capture screenshots directly from the interactive viewer (using the screenshot UI button), or programmatically like so:</p> <pre><code>import panopti\nviewer = panopti.connect(server_url=\"http://localhost:8080\", viewer_id='client')\n\n# Frame your shot:\nviewer.set_camera(\n    position=(5.0, 2.5, 7.5),\n    target=(0.0, 1.5, 0.0),\n    projection_mode=\"orthographic\"\n)\n\n# Take screenshot\nimg_arr = viewer.screenshot(filename='screenshot.png',\n                            bg_color=(0.75, 0.3, 0.3)) # use bg_color=None for fully transparent background\n\nviewer.hold()\n</code></pre> Screenshot - <code>viewer.screenshot()</code> <p>Capture a screenshot from the frontend viewer.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str or None</code> <p>If provided, the image will be saved to this path. Supported extensions are <code>png</code> (default), <code>jpg</code>, and <code>jpeg</code>.</p> <code>None</code> <code>bg_color</code> <code>tuple or None</code> <p>Background color as RGB values in [0,1] range. <code>None</code> results in a transparent background.</p> <code>None</code> <code>timeout</code> <code>float</code> <p>How long to wait for the screenshot data from the frontend. Default is 2 seconds.</p> <code>2.0</code> <p>Returns:</p> Type Description <code>Optional[ndarray]</code> <p>np.ndarray or None: RGB/RGBA image array, or <code>None</code> if the request timed out.</p>"},{"location":"viewer/transformations/","title":"Transformations & Gizmo","text":"<p>Panopti offers interactive mechanisms for translating, rotating, and scaling geometries through the transformation panel and through gizmos. To open the transformation panel, simply select a scene object. For the gizmo tool, see the toolbar. The transformated state of scene objects can be accessed by your code through property fields of scene geometries.</p> <p>Example: <pre><code>import panopti\nimport numpy as np\nviewer = panopti.connect(server_url=\"http://localhost:8080\", viewer_id=\"client\")\n\n# ... load triangle mesh vertices / faces ...\n\nviewer.add_mesh(vertices=vertices, faces=faces, name=\"MyMesh\")\n\n# Add a button that reads off the mesh's current transformation:\ndef my_button_callback(viewer):\n    mesh = viewer.get('MyMesh')\n\n    # request MyMesh's 4x4 transformation matrix:\n    trans_mat = mesh.trans_mat\n\n    # or directly access the transformed vertex tensor:\n    transformed_verts = mesh.viewer_verts\n\n    # ... do something here ...\n\nviewer.button(callback=my_button_callback, name='MyButton')\n\nviewer.hold() # prevent script from terminating\n</code></pre></p> <p>Each geometry type exposes helper attributes for retrieving the object's current 4x4 transformation matrix and associated quantities. For example, for Meshes and AnimatedMeshes objects, we offer: </p> SceneObject.trans_mat SceneObject.viewer_verts <p>See other geometry types for related functions, e.g. Points.</p>"},{"location":"viewer/transformations/#trans_mat","title":"trans_mat","text":"<p>Fetches the objects current 4x4 transformation matrix. <pre><code>viewer.get('MyObject').trans_mat\n</code></pre></p>"},{"location":"viewer/transformations/#viewer_verts","title":"viewer_verts","text":"<p>Fetches the objects current vertices with <code>trans_mat</code> pre-applied <pre><code>viewer.get('MyObject').viewer_verts\n</code></pre></p>"},{"location":"viewer/transformations/#gizmo","title":"Gizmo","text":"<p>The transformation gizmo can be enabled from the top left toolbar. It offers familiar controls to what you'd find in common 3D packages, select an object (either by clicking on it directly or in the layers panel), then the gizmo will appear.</p> <p>Controls:</p> Key Action T Switch to translate mode R Switch to rotate mode E Switch to scale mode Q Toggle between <code>world</code> and <code>local</code> transformations CTRL (hold) Snapping mode ESC Hide gizmo"},{"location":"viewer/transformations/#event-callbacks","title":"Event Callbacks","text":"<p>Both the transformation panel and gizmo offer event callbacks through <code>@viewer.events.update_object()</code> and <code>@viewer.events.gizmo()</code> respectively. See Viewer Events for details.</p>"}]}